# 路由系统

Miko 提供了灵活而强大的路由系统，支持路由宏、手动注册、路径参数、嵌套路由等功能。

## 路由定义方式

### 使用路由宏（推荐）

使用 `#[get]`、`#[post]` 等宏定义路由，配合 `#[miko]` 实现自动注册：

> **需要 `macro` feature，自动注册需要 `auto` feature**

```rust
use miko::*;
use miko::macros::*;

#[get("/")]
async fn index() -> &'static str {
    "Home"
}

#[get("/users")]
async fn list_users() -> &'static str {
    "User list"
}

#[post("/users")]
async fn create_user() -> &'static str {
    "User created"
}

#[miko]
async fn main() {
    // 路由自动收集和注册
}
```

### 手动注册路由（route的时候已经将state注入到了handler里，所以路由宏不支持state，并且需要先with_state再挂载路由）

如果不使用宏，可以手动注册：

```rust
use miko::*;

async fn index() -> &'static str {
    "Home"
}

#[tokio::main]
async fn main() {
    let router = Router::new()
        .get("/", index)
        .post("/users", create_user)
        .put("/users/{id}", update_user)
        .delete("/users/{id}", delete_user);

    let config = ApplicationConfig::default();
    Application::new(config, router).run().await.unwrap();
}
```

### 自定义方法和路径

使用 `#[route]` 宏自定义 HTTP 方法（其实其他的也可以拓展方法，例如`#[get("/", method="post,put")]`）：

```rust
use hyper::Method;

// 使用宏
#[route("/api/data", method = "get")]
async fn get_data() -> &'static str {
    "Data"
}

// 或手动注册
router.route(Method::PATCH, "/api/data", patch_handler);
```

## 可用的路由宏

Miko 提供了所有常用 HTTP 方法的宏：

| 宏 | HTTP 方法 | 用途 |
|---|-----------|------|
| `#[get]` | GET | 获取资源 |
| `#[post]` | POST | 创建资源 |
| `#[put]` | PUT | 更新资源（完整） |
| `#[patch]` | PATCH | 更新资源（部分） |
| `#[delete]` | DELETE | 删除资源 |
| `#[head]` | HEAD | 获取元信息 |
| `#[options]` | OPTIONS | 获取支持的方法 |

所有宏都支持 `#[route]` 的参数注解功能。

## 路径参数

### 定义路径参数

使用 `{参数名}` 定义路径参数：

```rust
#[get("/users/{id}")]
async fn get_user(Path(id): Path<u32>) -> String {
    format!("User ID: {}", id)
}

#[get("/posts/{post_id}/comments/{comment_id}")]
async fn get_comment(
    Path(post_id): Path<u32>,
    Path(comment_id): Path<u32>
) -> String {
    format!("Post: {}, Comment: {}", post_id, comment_id)
}
```

### 使用 `#[path]` 注解

使用宏的参数注解功能更简洁：

```rust
#[get("/users/{id}")]
async fn get_user(#[path] id: u32) -> String {
    format!("User ID: {}", id)
}

#[get("/users/{user_id}/posts/{post_id}")]
async fn get_user_post(
    #[path] user_id: u32,
    #[path] post_id: u32,
) -> String {
    format!("User {}, Post {}", user_id, post_id)
}
```

### 类型安全

路径参数支持任何实现 `FromStr` 的类型：

```rust
use uuid::Uuid;

#[get("/items/{id}")]
async fn get_item(#[path] id: Uuid) -> String {
    format!("Item UUID: {}", id)
}

#[get("/products/{slug}")]
async fn get_product(#[path] slug: String) -> String {
    format!("Product: {}", slug)
}
```

如果类型转换失败，会自动返回 400 Bad Request 错误。

## 路由嵌套

### 使用 `nest` 方法（注意state是继承自原本的router，换句话说route的时候已经将state注入到了handler里）

为一组路由添加统一前缀：

```rust
use miko::*;
use miko::macros::*;

// API v1 路由
#[get("/users")]
async fn v1_users() -> &'static str { "API v1 users" }

#[get("/posts")]
async fn v1_posts() -> &'static str { "API v1 posts" }

// API v2 路由
#[get("/users")]
async fn v2_users() -> &'static str { "API v2 users" }

#[tokio::main]
async fn main() {
    let v1_router = Router::new()
        .get("/users", v1_users)
        .get("/posts", v1_posts);

    let v2_router = Router::new()
        .get("/users", v2_users);

    let router = Router::new()
        .nest("/api/v1", v1_router)
        .nest("/api/v2", v2_router);

    // 访问 /api/v1/users, /api/v1/posts, /api/v2/users

    let config = ApplicationConfig::default();
    Application::new(config, router).run().await.unwrap();
}
```

### 使用 `merge` 方法

合并两个路由器：

```rust
let user_router = Router::new()
    .get("/users", list_users)
    .get("/users/{id}", get_user);

let post_router = Router::new()
    .get("/posts", list_posts)
    .get("/posts/{id}", get_post);

let router = Router::new()
    .merge(user_router)
    .merge(post_router);
```

### 模块化路由

推荐按功能模块组织路由：

```rust
// src/routes/users.rs
use miko::*;
use miko::macros::*;

#[get("/users")]
pub async fn list() -> &'static str { "Users" }

#[get("/users/{id}")]
pub async fn get(#[path] id: u32) -> String {
    format!("User {}", id)
}

pub fn router() -> Router {
    Router::new()
        .get("/users", list)
        .get("/users/{id}", get)
}

// src/routes/posts.rs
use miko::*;
use miko::macros::*;

#[get("/posts")]
pub async fn list() -> &'static str { "Posts" }

pub fn router() -> Router {
    Router::new()
        .get("/posts", list)
}

// src/main.rs
mod routes;

#[tokio::main]
async fn main() {
    let router = Router::new()
        .merge(routes::users::router())
        .merge(routes::posts::router());

    let config = ApplicationConfig::default();
    Application::new(config, router).run().await.unwrap();
}
```

## 模块路由与前缀

### #[prefix] 宏

使用 `#[prefix]` 宏为模块内所有路由添加路径前缀:

```rust
use miko::*;
use miko::macros::*;

#[prefix("/api")]
mod api {
    #[get("/users")]
    async fn list_users() -> &'static str {
        "users"  // 实际路径: GET /api/users
    }

    #[get("/posts")]
    async fn list_posts() -> &'static str {
        "posts"  // 实际路径: GET /api/posts
    }
}

#[prefix("/admin")]
mod admin {
    #[get("/users")]
    async fn admin_users() -> &'static str {
        "admin users"  // 实际路径: GET /admin/users
    }
}

#[miko]
async fn main() {
    // 模块内路由自动带前缀
}
```

### 嵌套前缀

`#[prefix]` 支持嵌套使用:

```rust
#[prefix("/api")]
mod api {
    #[prefix("/v1")]
    mod v1 {
        #[get("/users")]
        async fn list_users() -> &'static str {
            "v1 users"  // 实际路径: GET /api/v1/users
        }
    }

    #[prefix("/v2")]
    mod v2 {
        #[get("/users")]
        async fn list_users() -> &'static str {
            "v2 users"  // 实际路径: GET /api/v2/users
        }
    }
}
```

### prefix 与 nest 的区别

| 特性 | `#[prefix]` | `Router::nest` |
|------|-------------|----------------|
| 使用位置 | 模块级别（编译时） | Router 级别（运行时） |
| 路径处理 | 简单前缀拼接 | 真正的路由嵌套，会修改内部路径 |
| 使用场景 | 模块化代码组织 | 动态路由组合 |

```rust
// #[prefix] - 编译时前缀
#[prefix("/api")]
mod api {
    #[get("/users")]  // 编译后: GET /api/users
    async fn users() { }
}

// nest - 运行时嵌套
let api_router = Router::new()
    .get("/users", users);

let router = Router::new()
    .nest("/api", api_router);  // 运行时: GET /api/users
```

### 组合使用

`#[prefix]` 可以和 `#[layer]` 一起使用:

```rust
use tower_http::timeout::TimeoutLayer;
use std::time::Duration;

#[prefix("/api")]
#[layer(TimeoutLayer::new(Duration::from_secs(30)))]
mod api {
    #[get("/users")]
    async fn users() -> &'static str {
        "users"  // GET /api/users，带 30 秒超时
    }
}
```

## 路由优先级

路由匹配，静态路由会被优先匹配：

```rust
let router = Router::new()
    .get("/users/me", get_current_user)      // 先注册具体路径
    .get("/users/{id}", get_user);           // 后注册参数路径
```

`/users/me` 和 `/users/{id}` 都匹配到，但是me是静态路由

## 通配符路由

匹配任意路径段：

```rust
// 匹配 /files/ 后的所有路径
#[get("/files/{*path}")]
async fn serve_file(Path(path): Path<String>) -> String {
    format!("Serving file: {}", path)
}

// 访问 /files/docs/guide.md
// path = "docs/guide.md"
```

## 路由组与中间件

为一组路由应用相同的中间件（在merge，nest，into_tower_service才会生效，所以添加时机要求比较宽松）：

```rust
use tower::ServiceBuilder;
use tower_http::trace::TraceLayer;

let protected_router = Router::new()
    .get("/admin/users", admin_users)
    .get("/admin/settings", admin_settings)
    .with_layer(auth_middleware());  // 只应用于这些路由

let public_router = Router::new()
    .get("/", index)
    .get("/about", about);

let router = Router::new()
    .merge(public_router)
    .merge(protected_router)
    .layer(TraceLayer::new_for_http());  // 应用于所有路由
```

详见 [中间件与层](中间件与层.md)。

## 路由处理器

### Handler 签名

Handler 是任何满足以下条件的异步函数：
- 参数实现 `FromRequest` 或 `FromRequestParts`
- 返回类型实现 `IntoResponse`

```rust
// 无参数
async fn handler() -> &'static str { "Hello" }

// 单个参数
async fn with_json(Json(data): Json<MyData>) -> Json<Response> {
    // ...
}

// 多个参数
async fn complex_handler(
    Path(id): Path<u32>,
    Query(params): Query<HashMap<String, String>>,
    Json(body): Json<CreateData>,
    State(db): State<Database>,
) -> AppResult<Json<Response>> {
    // ...
}
```

### 参数提取顺序

提取器有两种类型：

1. **FromRequestParts** - 不消费请求体（Path、Query、Headers、State 等）
2. **FromRequest** - 可能消费请求体（Json、Form、Multipart 等）

你可以有多个 `FromRequestParts` 提取器，但只能有一个 `FromRequest` 提取器：

```rust
// ✅ 正确
async fn handler(
    Path(id): Path<u32>,           // FromRequestParts
    Query(q): Query<MyQuery>,       // FromRequestParts
    headers: HeaderMap,             // FromRequestParts
    Json(body): Json<MyData>,       // FromRequest
) { }

// ❌ 错误 - 不能有两个 FromRequest
async fn bad_handler(
    Json(body1): Json<Data1>,       // FromRequest
    Json(body2): Json<Data2>,       // FromRequest - 编译错误！
) { }
```

### 返回类型

我们路由相关类型定义如下
```rust
pub type RespBody = BoxBody<Bytes, Infallible>;
pub type Resp = Response<RespBody>;
pub type Req = Request<RespBody>;
```

Handler 可以返回任何实现 `IntoResponse` 的类型：

```rust
// 字符串
async fn text() -> &'static str { "Hello" }

// JSON
async fn json() -> Json<User> { Json(user) }

// 带状态码
async fn created() -> (StatusCode, Json<User>) {
    (StatusCode::CREATED, Json(user))
}

// Result
async fn fallible() -> AppResult<Json<User>> {
    Ok(Json(user))
}

// 自定义响应（）
async fn custom() -> impl IntoResponse {
    Response::builder()
        .status(StatusCode::OK)
        .header("X-Custom", "value")
        .body(Full::new(Bytes::from("Hello")).boxed())
        .unwrap()
}
```

详见 [响应处理](响应处理.md)。

## 完整示例

一个展示各种路由功能的完整示例：

```rust
use miko::{*, extractor::{Json, Path, Query}};
use miko::macros::*;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Serialize, Deserialize)]
struct User {
    id: u32,
    name: String,
}

#[derive(Serialize, Deserialize, Debug)]
struct MyQuery {
    id: u32,
    name: String,
}

// 基础路由
#[get("/")]
async fn index() -> &'static str {
    "Welcome"
}

// 路径参数
#[get("/users/{id}")]
async fn get_user(#[path] id: u32) -> Json<User> {
    Json(User { id, name: format!("User {}", id) })
}

// 查询参数
#[get("/search")]
async fn search(Query(params): Query<MyQuery>) -> String {
    format!("Query: {:?}", params)
}

// POST 请求
#[post("/users")]
async fn create_user(Json(user): Json<User>) -> (StatusCode, Json<User>) {
    (StatusCode::CREATED, Json(user))
}

// 多个路径参数
#[get("/users/{user_id}/posts/{post_id}")]
async fn get_user_post(
    #[path] user_id: u32,
    #[path] post_id: u32,
) -> String {
    format!("User {}, Post {}", user_id, post_id)
}

#[miko]
async fn main() {
    println!("🚀 Server running on http://localhost:8080");
}
```

## 下一步

- 🔍 学习 [请求提取器](请求提取器.md) 的详细用法
- 📤 了解 [响应处理](响应处理.md) 的各种方式
- 🔐 使用 [中间件与层](中间件与层.md) 添加认证等功能
