# 高级特性

本文档介绍 Miko 框架的高级功能，包括自动路由注册、静态文件服务、文件上传和 Trace ID 追踪系统。

## 自动路由注册

> **需要 `auto` feature**

使用 `#[miko]` 宏可以自动收集和注册所有路由，无需手动添加：

### 基础用法

```rust
use miko::*;

#[get("/")]
async fn index() -> &'static str {
    "Hello, World!"
}

#[get("/users")]
async fn list_users() -> Json<Vec<String>> {
    Json(vec!["Alice".into(), "Bob".into()])
}

#[post("/users")]
async fn create_user(Json(data): Json<serde_json::Value>) -> StatusCode {
    StatusCode::CREATED
}

// 自动注册所有路由
#[miko]
async fn main() {
    println!("🚀 Server running on http://localhost:8080");
}
```

### `#[miko]` 宏做了什么

`#[miko]` 宏会展开为：

```rust
#[tokio::main]
async fn main() {
    // 1. 初始化依赖注入容器
    miko::auto::init_container().await;
    
    // 2. 加载配置文件 (config.toml + config.{dev/prod}.toml)
    let config = miko::app::ApplicationConfig::load();
    
    // 3. 收集所有 #[get]、#[post] 等宏标记的路由
    let router = miko::auto::collect_routes();
    
    // 4. 创建并运行应用
    miko::app::Application::new(config, router)
        .run()
        .await
        .unwrap();
}
```

### 手动控制

如果需要更多控制，可以不使用 `#[miko]` 宏：

```rust
use miko::*;
use miko::auto::init_container;

#[get("/")]
async fn index() -> &'static str {
    "Hello"
}

#[tokio::main]
async fn main() {
    // 手动初始化
    init_container().await;
    
    // 自定义配置
    let mut config = ApplicationConfig::default();
    config.port = 9000;
    
    // 手动收集路由
    let router = miko::auto::collect_routes();
    
    // 添加额外的中间件
    let router = router.layer(/* ... */);
    
    Application::new(config, router).run().await.unwrap();
}
```

## 静态文件服务

> **需要 `ext` feature**

Miko 提供了静态文件服务功能，支持目录映射和 SPA 应用。

### 基础用法

```rust
use miko::*;
use miko::ext::static_svc::StaticSvc;

#[miko]
async fn main() {
    // 挂载静态文件目录
    router.nest_service("/static", StaticSvc::builder("public").build());
    
    println!("📁 Static files at http://localhost:8080/static/");
}
```

访问示例：
- `/static/index.html` → `public/index.html`
- `/static/css/style.css` → `public/css/style.css`
- `/static/images/logo.png` → `public/images/logo.png`

### SPA 模式

对于 Vue/React 等单页应用，启用 SPA 回退：

```rust
use miko::ext::static_svc::StaticSvc;

#[miko]
async fn main() {
    // 所有未匹配的路由都返回 index.html
    router.nest_service(
        "/",
        StaticSvc::builder("dist")
            .spa_fallback(true)  // 启用 SPA 回退
            .build()
    );
}
```

这样配置后：
- `/` → `dist/index.html`
- `/about` → `dist/index.html` (由前端路由处理)
- `/static/app.js` → `dist/static/app.js`

### 完整配置

```rust
use miko::ext::static_svc::StaticSvc;

#[get("/api/users")]
async fn api_users() -> Json<Vec<String>> {
    Json(vec!["Alice".into()])
}

#[miko]
async fn main() {
    // API 路由优先级更高
    // （路由在静态服务之前定义）
    
    // 静态文件服务
    router.nest_service(
        "/assets",
        StaticSvc::builder("public/assets").build()
    );
    
    // SPA 应用（放在最后，作为兜底）
    router.nest_service(
        "/",
        StaticSvc::builder("public")
            .spa_fallback(true)
            .build()
    );
    
    println!("🌐 SPA at http://localhost:8080/");
    println!("📦 API at http://localhost:8080/api/");
}
```

### 安全性

StaticSvc 会自动防止路径遍历攻击：

```rust
// ❌ 这些请求会被阻止
// /static/../../../etc/passwd
// /static/..%2F..%2Fetc%2Fpasswd

// ✅ 只能访问指定目录下的文件
// /static/style.css
// /static/images/logo.png
```

## 文件上传

> **需要 `ext` feature**

Miko 提供了便捷的文件上传服务。

### 使用 Uploader 服务

```rust
use miko::*;
use miko::ext::uploader::{Uploader, DiskStorage, DiskStorageConfig};

#[miko]
async fn main() {
    // 挂载单文件上传服务
    router.service(
        "/upload",
        Uploader::single(DiskStorage::new(
            "uploads",                                    // 保存目录
            DiskStorageConfig::default().max_size(50 * 1024 * 1024)  // 50MB
        ))
    );
    
    println!("📤 Upload endpoint: http://localhost:8080/upload");
}
```

### DiskStorageConfig 配置

```rust
use miko::ext::uploader::{DiskStorage, DiskStorageConfig};

let storage = DiskStorage::new(
    "uploads",
    DiskStorageConfig::default()
        .max_size(10 * 1024 * 1024)  // 最大 10MB
        .allowed_extensions(vec!["jpg".into(), "png".into(), "pdf".into()])
        .allowed_mime_types(vec!["image/jpeg".into(), "image/png".into()])
        .filename_mapper(|original_name| {
            // 自定义文件名生成
            format!("{}_{}", chrono::Utc::now().timestamp(), original_name)
        })
);
```

### 使用 MultipartResult

更灵活的方式是使用 `MultipartResult` 提取器：

```rust
use miko::{*, extractor::multipart::MultipartResult};

#[post("/upload")]
async fn upload(multipart: MultipartResult) -> AppResult<Json<serde_json::Value>> {
    let mut uploaded = vec![];
    
    for (field_name, files) in &multipart.files {
        for file in files {
            // 验证文件类型
            if let Some(mime) = &file.content_type {
                if !mime.type_().as_str().starts_with("image/") {
                    return Err(AppError::BadRequest(
                        format!("{} is not an image", file.filename)
                    ));
                }
            }
            
            // 验证文件大小
            const MAX_SIZE: usize = 5 * 1024 * 1024;  // 5MB
            if file.size > MAX_SIZE {
                return Err(AppError::BadRequest(
                    format!("{} exceeds 5MB", file.filename)
                ));
            }
            
            // 保存文件
            let dest = format!("uploads/{}", file.filename);
            file.linker.transfer_to(&dest).await?;
            
            uploaded.push(serde_json::json!({
                "field": field_name,
                "filename": file.filename,
                "size": file.size,
                "path": dest,
            }));
        }
    }
    
    Ok(Json(serde_json::json!({
        "success": true,
        "files": uploaded,
    })))
}
```

### 图片上传示例

```rust
use miko::{*, extractor::multipart::MultipartResult};
use image::ImageFormat;

#[post("/upload-image")]
async fn upload_image(multipart: MultipartResult) -> AppResult<Json<serde_json::Value>> {
    if let Some(files) = multipart.files.get("image") {
        for file in files {
            // 验证 MIME 类型
            if let Some(mime) = &file.content_type {
                if mime.type_().as_str() != "image" {
                    return Err(AppError::BadRequest("Not an image file".into()));
                }
            }
            
            // 读取图片并验证
            let bytes = file.linker.read_and_drop_file(self).await?;
            let img = image::load_from_memory(&bytes)
                .map_err(|e| AppError::BadRequest(format!("Invalid image: {}", e)))?;
            
            // 生成缩略图
            let thumbnail = img.resize(200, 200, image::imageops::FilterType::Lanczos3);
            
            // 保存原图和缩略图
            let filename = format!("{}_{}", chrono::Utc::now().timestamp(), file.filename);
            let thumb_filename = format!("thumb_{}", filename);
            
            tokio::fs::write(format!("uploads/{}", filename), bytes).await?;
            thumbnail.save_with_format(
                format!("uploads/{}", thumb_filename),
                ImageFormat::Jpeg
            )?;
            
            return Ok(Json(serde_json::json!({
                "success": true,
                "original": filename,
                "thumbnail": thumb_filename,
            })));
        }
    }
    
    Err(AppError::BadRequest("No image uploaded".into()))
}
```

### 前端示例

HTML 表单：

```html
<form action="/upload" method="POST" enctype="multipart/form-data">
    <input type="file" name="file" accept="image/*" required>
    <button type="submit">Upload</button>
</form>
```

JavaScript Fetch:

```javascript
async function uploadFile(file) {
    const formData = new FormData();
    formData.append('file', file);
    
    const response = await fetch('/upload', {
        method: 'POST',
        body: formData
    });
    
    const result = await response.json();
    console.log('Uploaded:', result);
}
```

## Trace ID 追踪

Miko 提供了自动 Trace ID 系统，用于追踪和关联请求。

### 自动 Trace ID

所有错误响应都会自动包含 `trace_id` 字段：

```rust
use miko::*;

#[get("/error")]
async fn error_handler() -> AppResult<String> {
    Err(AppError::NotFound("Resource not found".into()))
}

// 响应示例：
// {
//   "status": 404,
//   "error": "NOT_FOUND",
//   "message": "Resource not found",
//   "trace_id": "550e8400-e29b-41d4-a716-446655440000",
//   "timestamp": "2024-01-01T12:00:00Z"
// }
```

### Trace ID 来源

框架会按以下优先级获取 Trace ID：

1. **请求头 `x-trace-id`**
2. **请求头 `x-request-id`**
3. **自动生成 UUID**

```bash
# 使用自定义 Trace ID
curl -H "x-trace-id: my-custom-trace-123" http://localhost:8080/api

# 自动生成 Trace ID
curl http://localhost:8080/api
```

### 手动使用 Trace ID

可以在代码中手动获取和设置 Trace ID：

```rust
use miko::error::{get_trace_id, set_trace_id};

#[get("/api/data")]
async fn get_data() -> AppResult<String> {
    // 获取当前请求的 Trace ID
    if let Some(trace_id) = get_trace_id() {
        println!("Processing request: {}", trace_id);
        
        // 记录到日志系统
        tracing::info!(trace_id = %trace_id, "Fetching data");
    }
    
    // 业务逻辑
    Ok("Data".to_string())
}
```

### 中间件中使用 Trace ID

```rust
use miko::error::{get_trace_id, set_trace_id};
use tower::{Layer, Service};

// 自定义中间件记录 Trace ID
#[derive(Clone)]
struct TraceLayer;

impl<S> Layer<S> for TraceLayer {
    type Service = TraceMiddleware<S>;
    
    fn layer(&self, inner: S) -> Self::Service {
        TraceMiddleware { inner }
    }
}

#[derive(Clone)]
struct TraceMiddleware<S> {
    inner: S,
}

impl<S, ReqBody, ResBody> Service<Request<ReqBody>> for TraceMiddleware<S>
where
    S: Service<Request<ReqBody>, Response = Response<ResBody>>,
{
    type Response = S::Response;
    type Error = S::Error;
    type Future = S::Future;
    
    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }
    
    fn call(&mut self, request: Request<ReqBody>) -> Self::Future {
        // 从请求头获取或生成 Trace ID
        let trace_id = request
            .headers()
            .get("x-trace-id")
            .or_else(|| request.headers().get("x-request-id"))
            .and_then(|v| v.to_str().ok())
            .map(|s| s.to_string())
            .unwrap_or_else(|| uuid::Uuid::new_v4().to_string());
        
        // 设置到 thread-local
        set_trace_id(Some(trace_id.clone()));
        
        tracing::info!(
            method = %request.method(),
            uri = %request.uri(),
            trace_id = %trace_id,
            "Incoming request"
        );
        
        self.inner.call(request)
    }
}

// 使用
#[miko]
async fn main() {
    router.layer(TraceLayer);
}
```

### API 文档

**Trace ID 相关函数**：

```rust
// 获取当前请求的 Trace ID
pub fn get_trace_id() -> Option<String>

// 设置当前请求的 Trace ID
pub fn set_trace_id(trace_id: Option<String>)

// 清除当前请求的 Trace ID
pub fn clear_trace_id()
```
