# é«˜çº§ç‰¹æ€§

æœ¬æ–‡æ¡£ä»‹ç» Miko æ¡†æ¶çš„é«˜çº§åŠŸèƒ½ï¼ŒåŒ…æ‹¬è‡ªåŠ¨è·¯ç”±æ³¨å†Œã€é™æ€æ–‡ä»¶æœåŠ¡ã€æ–‡ä»¶ä¸Šä¼ å’Œ Trace ID è¿½è¸ªç³»ç»Ÿã€‚

## è‡ªåŠ¨è·¯ç”±æ³¨å†Œ

> **éœ€è¦ `auto` feature**

ä½¿ç”¨ `#[miko]` å®å¯ä»¥è‡ªåŠ¨æ”¶é›†å’Œæ³¨å†Œæ‰€æœ‰è·¯ç”±ï¼Œæ— éœ€æ‰‹åŠ¨æ·»åŠ ï¼š

### åŸºç¡€ç”¨æ³•

```rust
use miko::*;
use miko::macros::*;

#[get("/")]
async fn index() -> &'static str {
    "Hello, World!"
}

#[get("/users")]
async fn list_users() -> Json<Vec<String>> {
    Json(vec!["Alice".into(), "Bob".into()])
}

#[post("/users")]
async fn create_user(Json(data): Json<serde_json::Value>) -> StatusCode {
    StatusCode::CREATED
}

// è‡ªåŠ¨æ³¨å†Œæ‰€æœ‰è·¯ç”±
#[miko]
async fn main() {
    println!("ğŸš€ Server running on http://localhost:8080");
}
```

### `#[miko]` å®åšäº†ä»€ä¹ˆ

`#[miko]` å®ä¼šå±•å¼€ä¸ºï¼š

```rust
#[tokio::main]
async fn main() {
    // 1. åˆå§‹åŒ–ä¾èµ–æ³¨å…¥å®¹å™¨
    miko::auto::init_container().await;

    // 2. åŠ è½½é…ç½®æ–‡ä»¶ (config.toml + config.{dev/prod}.toml)
    let config = miko::app::ApplicationConfig::load();

    // 3. æ”¶é›†æ‰€æœ‰ #[get]ã€#[post] ç­‰å®æ ‡è®°çš„è·¯ç”±
    let router = miko::auto::collect_routes();

    // 4. åˆ›å»ºå¹¶è¿è¡Œåº”ç”¨
    miko::app::Application::new(config, router)
        .run()
        .await
        .unwrap();
}
```

### æ‰‹åŠ¨æ§åˆ¶

å¦‚æœéœ€è¦æ›´å¤šæ§åˆ¶ï¼Œå¯ä»¥ä¸ä½¿ç”¨ `#[miko]` å®ï¼š

```rust
use miko::*;
use miko::macros::*;
use miko::auto::init_container;

#[get("/")]
async fn index() -> &'static str {
    "Hello"
}

#[tokio::main]
async fn main() {
    // æ‰‹åŠ¨åˆå§‹åŒ–
    init_container().await;

    // è‡ªå®šä¹‰é…ç½®
    let mut config = ApplicationConfig::default();
    config.port = 9000;

    // æ‰‹åŠ¨æ”¶é›†è·¯ç”±
    let router = miko::auto::collect_routes();

    // æ·»åŠ é¢å¤–çš„ä¸­é—´ä»¶
    let router = router.layer(/* ... */);

    Application::new(config, router).run().await.unwrap();
}
```

## é™æ€æ–‡ä»¶æœåŠ¡

> **éœ€è¦ `ext` feature**

Miko æä¾›äº†é™æ€æ–‡ä»¶æœåŠ¡åŠŸèƒ½ï¼Œæ”¯æŒç›®å½•æ˜ å°„å’Œ SPA åº”ç”¨ã€‚

### åŸºç¡€ç”¨æ³•

```rust
use miko::*;
use miko::macros::*;
use miko::ext::static_svc::StaticSvc;

#[miko]
async fn main() {
    // æŒ‚è½½é™æ€æ–‡ä»¶ç›®å½•
    router.nest_service("/static", StaticSvc::builder("public").build());

    println!("ğŸ“ Static files at http://localhost:8080/static/");
}
```

è®¿é—®ç¤ºä¾‹ï¼š
- `/static/index.html` â†’ `public/index.html`
- `/static/css/style.css` â†’ `public/css/style.css`
- `/static/images/logo.png` â†’ `public/images/logo.png`

### SPA æ¨¡å¼

å¯¹äº Vue/React ç­‰å•é¡µåº”ç”¨ï¼Œå¯ç”¨ SPA å›é€€ï¼š

```rust
use miko::ext::static_svc::StaticSvc;

#[miko]
async fn main() {
    // æ‰€æœ‰æœªåŒ¹é…çš„è·¯ç”±éƒ½è¿”å› index.html
    router.nest_service(
        "/",
        StaticSvc::builder("dist")
            .spa_fallback(true)  // å¯ç”¨ SPA å›é€€
            .build()
    );
}
```

è¿™æ ·é…ç½®åï¼š
- `/` â†’ `dist/index.html`
- `/about` â†’ `dist/index.html` (ç”±å‰ç«¯è·¯ç”±å¤„ç†)
- `/static/app.js` â†’ `dist/static/app.js`

### å®Œæ•´é…ç½®

```rust
use miko::ext::static_svc::StaticSvc;

#[get("/api/users")]
async fn api_users() -> Json<Vec<String>> {
    Json(vec!["Alice".into()])
}

#[miko]
async fn main() {
    // API è·¯ç”±ä¼˜å…ˆçº§æ›´é«˜
    // ï¼ˆè·¯ç”±åœ¨é™æ€æœåŠ¡ä¹‹å‰å®šä¹‰ï¼‰

    // é™æ€æ–‡ä»¶æœåŠ¡
    router.nest_service(
        "/assets",
        StaticSvc::builder("public/assets").build()
    );

    // SPA åº”ç”¨ï¼ˆæ”¾åœ¨æœ€åï¼Œä½œä¸ºå…œåº•ï¼‰
    router.nest_service(
        "/",
        StaticSvc::builder("public")
            .spa_fallback(true)
            .build()
    );

    println!("ğŸŒ SPA at http://localhost:8080/");
    println!("ğŸ“¦ API at http://localhost:8080/api/");
}
```

### å®‰å…¨æ€§

StaticSvc ä¼šè‡ªåŠ¨é˜²æ­¢è·¯å¾„éå†æ”»å‡»ï¼š

```rust
// âŒ è¿™äº›è¯·æ±‚ä¼šè¢«é˜»æ­¢
// /static/../../../etc/passwd
// /static/..%2F..%2Fetc%2Fpasswd

// âœ… åªèƒ½è®¿é—®æŒ‡å®šç›®å½•ä¸‹çš„æ–‡ä»¶
// /static/style.css
// /static/images/logo.png
```

## æ–‡ä»¶ä¸Šä¼ 

> **éœ€è¦ `ext` feature**

Miko æä¾›äº†ä¾¿æ·çš„æ–‡ä»¶ä¸Šä¼ æœåŠ¡ã€‚

### ä½¿ç”¨ Uploader æœåŠ¡

```rust
use miko::*;
use miko::macros::*;
use miko::ext::uploader::{Uploader, DiskStorage, DiskStorageConfig};

#[miko]
async fn main() {
    // æŒ‚è½½å•æ–‡ä»¶ä¸Šä¼ æœåŠ¡
    router.service(
        "/upload",
        Uploader::single(DiskStorage::new(
            "uploads",                                    // ä¿å­˜ç›®å½•
            DiskStorageConfig::default().max_size(50 * 1024 * 1024)  // 50MB
        ))
    );

    println!("ğŸ“¤ Upload endpoint: http://localhost:8080/upload");
}
```

### DiskStorageConfig é…ç½®

```rust
use miko::ext::uploader::{DiskStorage, DiskStorageConfig};

let storage = DiskStorage::new(
    "uploads",
    DiskStorageConfig::default()
        .max_size(10 * 1024 * 1024)  // æœ€å¤§ 10MB
        .allowed_extensions(vec!["jpg".into(), "png".into(), "pdf".into()])
        .allowed_mime_types(vec!["image/jpeg".into(), "image/png".into()])
        .filename_mapper(|original_name| {
            // è‡ªå®šä¹‰æ–‡ä»¶åç”Ÿæˆ
            format!("{}_{}", chrono::Utc::now().timestamp(), original_name)
        })
);
```

### ä½¿ç”¨ MultipartResult

æ›´çµæ´»çš„æ–¹å¼æ˜¯ä½¿ç”¨ `MultipartResult` æå–å™¨ï¼š

```rust
use miko::{*, macros::*, extractor::multipart::MultipartResult};

#[post("/upload")]
async fn upload(multipart: MultipartResult) -> AppResult<Json<serde_json::Value>> {
    let mut uploaded = vec![];

    for (field_name, files) in &multipart.files {
        for file in files {
            // éªŒè¯æ–‡ä»¶ç±»å‹
            if let Some(mime) = &file.content_type {
                if !mime.type_().as_str().starts_with("image/") {
                    return Err(AppError::BadRequest(
                        format!("{} is not an image", file.filename)
                    ));
                }
            }

            // éªŒè¯æ–‡ä»¶å¤§å°
            const MAX_SIZE: usize = 5 * 1024 * 1024;  // 5MB
            if file.size > MAX_SIZE {
                return Err(AppError::BadRequest(
                    format!("{} exceeds 5MB", file.filename)
                ));
            }

            // ä¿å­˜æ–‡ä»¶
            let dest = format!("uploads/{}", file.filename);
            file.linker.transfer_to(&dest).await?;

            uploaded.push(serde_json::json!({
                "field": field_name,
                "filename": file.filename,
                "size": file.size,
                "path": dest,
            }));
        }
    }

    Ok(Json(serde_json::json!({
        "success": true,
        "files": uploaded,
    })))
}
```

### å›¾ç‰‡ä¸Šä¼ ç¤ºä¾‹

```rust
use miko::{*, macros::*, extractor::multipart::MultipartResult};
use image::ImageFormat;

#[post("/upload-image")]
async fn upload_image(mut multipart: MultipartResult) -> AppResult<Json<serde_json::Value>> {
   // ä½¿ç”¨ remove è·å–æ–‡ä»¶æ‰€æœ‰æƒï¼Œå› ä¸º read_and_drop_file éœ€è¦æ¶ˆè´¹æ–‡ä»¶
   if let Some(files) = multipart.files.remove("image") {
        for file in files {
            // éªŒè¯ MIME ç±»å‹
            if let Some(mime) = &file.content_type {
                if mime.type_().as_str() != "image" {
                    return Err(AppError::BadRequest("Not an image file".into()));
                }
            }

            // è¯»å–å›¾ç‰‡å¹¶éªŒè¯
           let bytes = file.linker.read_and_drop_file().await?;
            let img = image::load_from_memory(&bytes)
                .map_err(|e| AppError::BadRequest(format!("Invalid image: {}", e)))?;

            // ç”Ÿæˆç¼©ç•¥å›¾
            let thumbnail = img.resize(200, 200, image::imageops::FilterType::Lanczos3);

            // ä¿å­˜åŸå›¾å’Œç¼©ç•¥å›¾
            let filename = format!("{}_{}", chrono::Utc::now().timestamp(), file.filename);
            let thumb_filename = format!("thumb_{}", filename);

            tokio::fs::write(format!("uploads/{}", filename), bytes).await?;
            thumbnail.save_with_format(
                format!("uploads/{}", thumb_filename),
                ImageFormat::Jpeg
            )?;

            return Ok(Json(serde_json::json!({
                "success": true,
                "original": filename,
                "thumbnail": thumb_filename,
            })));
        }
    }

    Err(AppError::BadRequest("No image uploaded".into()))
}
```

### å‰ç«¯ç¤ºä¾‹

HTML è¡¨å•ï¼š

```html
<form action="/upload" method="POST" enctype="multipart/form-data">
    <input type="file" name="file" accept="image/*" required>
    <button type="submit">Upload</button>
</form>
```

JavaScript Fetch:

```javascript
async function uploadFile(file) {
    const formData = new FormData();
    formData.append('file', file);

    const response = await fetch('/upload', {
        method: 'POST',
        body: formData
    });

    const result = await response.json();
    console.log('Uploaded:', result);
}
```

## Trace ID è¿½è¸ª

Miko æä¾›äº†è‡ªåŠ¨ Trace ID ç³»ç»Ÿï¼Œç”¨äºè¿½è¸ªå’Œå…³è”è¯·æ±‚ã€‚

### è‡ªåŠ¨ Trace ID

æ‰€æœ‰é”™è¯¯å“åº”éƒ½ä¼šè‡ªåŠ¨åŒ…å« `trace_id` å­—æ®µï¼š

```rust
use miko::*;
use miko::macros::*;

#[get("/error")]
async fn error_handler() -> AppResult<String> {
    Err(AppError::NotFound("Resource not found".into()))
}

// å“åº”ç¤ºä¾‹ï¼š
// {
//   "status": 404,
//   "error": "NOT_FOUND",
//   "message": "Resource not found",
//   "trace_id": "550e8400-e29b-41d4-a716-446655440000",
//   "timestamp": "2024-01-01T12:00:00Z"
// }
```

### Trace ID æ¥æº

æ¡†æ¶ä¼šæŒ‰ä»¥ä¸‹ä¼˜å…ˆçº§è·å– Trace IDï¼š

1. **è¯·æ±‚å¤´ `x-trace-id`**
2. **è¯·æ±‚å¤´ `x-request-id`**
3. **è‡ªåŠ¨ç”Ÿæˆ UUID**

```bash
# ä½¿ç”¨è‡ªå®šä¹‰ Trace ID
curl -H "x-trace-id: my-custom-trace-123" http://localhost:8080/api

# è‡ªåŠ¨ç”Ÿæˆ Trace ID
curl http://localhost:8080/api
```

### æ‰‹åŠ¨ä½¿ç”¨ Trace ID

å¯ä»¥åœ¨ä»£ç ä¸­æ‰‹åŠ¨è·å–å’Œè®¾ç½® Trace IDï¼š

```rust
use miko::error::{get_trace_id, set_trace_id};

#[get("/api/data")]
async fn get_data() -> AppResult<String> {
    // è·å–å½“å‰è¯·æ±‚çš„ Trace ID
    if let Some(trace_id) = get_trace_id() {
        println!("Processing request: {}", trace_id);

        // è®°å½•åˆ°æ—¥å¿—ç³»ç»Ÿ
        tracing::info!(trace_id = %trace_id, "Fetching data");
    }

    // ä¸šåŠ¡é€»è¾‘
    Ok("Data".to_string())
}
```

### ä¸­é—´ä»¶ä¸­ä½¿ç”¨ Trace ID

```rust
use miko::error::{get_trace_id, set_trace_id};
use tower::{Layer, Service};

// è‡ªå®šä¹‰ä¸­é—´ä»¶è®°å½• Trace ID
#[derive(Clone)]
struct TraceLayer;

impl<S> Layer<S> for TraceLayer {
    type Service = TraceMiddleware<S>;

    fn layer(&self, inner: S) -> Self::Service {
        TraceMiddleware { inner }
    }
}

#[derive(Clone)]
struct TraceMiddleware<S> {
    inner: S,
}

impl<S, ReqBody, ResBody> Service<Request<ReqBody>> for TraceMiddleware<S>
where
    S: Service<Request<ReqBody>, Response = Response<ResBody>>,
{
    type Response = S::Response;
    type Error = S::Error;
    type Future = S::Future;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, request: Request<ReqBody>) -> Self::Future {
        // ä»è¯·æ±‚å¤´è·å–æˆ–ç”Ÿæˆ Trace ID
        let trace_id = request
            .headers()
            .get("x-trace-id")
            .or_else(|| request.headers().get("x-request-id"))
            .and_then(|v| v.to_str().ok())
            .map(|s| s.to_string())
            .unwrap_or_else(|| uuid::Uuid::new_v4().to_string());

        // è®¾ç½®åˆ° thread-local
        set_trace_id(Some(trace_id.clone()));

        tracing::info!(
            method = %request.method(),
            uri = %request.uri(),
            trace_id = %trace_id,
            "Incoming request"
        );

        self.inner.call(request)
    }
}

// ä½¿ç”¨
#[miko]
async fn main() {
    router.layer(TraceLayer);
}
```

### API æ–‡æ¡£

**Trace ID ç›¸å…³å‡½æ•°**ï¼š

```rust
// è·å–å½“å‰è¯·æ±‚çš„ Trace ID
pub fn get_trace_id() -> Option<String>

// è®¾ç½®å½“å‰è¯·æ±‚çš„ Trace ID
pub fn set_trace_id(trace_id: Option<String>)

// æ¸…é™¤å½“å‰è¯·æ±‚çš„ Trace ID
pub fn clear_trace_id()
```

## ä¼˜é›…åœæœº (Graceful Shutdown)

Miko æ¡†æ¶å†…ç½®äº†ç”Ÿäº§çº§çš„ä¼˜é›…åœæœºæœºåˆ¶ï¼Œç¡®ä¿åœ¨æœåŠ¡åœæ­¢æ—¶ä¸ä¼šå¼ºåˆ¶ä¸­æ–­æ­£åœ¨å¤„ç†çš„è¯·æ±‚ã€‚

### å·¥ä½œåŸç†

å½“åº”ç”¨å¯åŠ¨åï¼Œ`Application::run` ä¼šè‡ªåŠ¨ç›‘å¬ç³»ç»Ÿçš„ç»ˆæ­¢ä¿¡å·ï¼ˆLinux/macOS çš„ `SIGTERM`/`SIGINT`ï¼ŒWindows çš„ `Ctrl+C`ï¼‰ã€‚

å½“æ”¶åˆ°ä¿¡å·æ—¶ï¼š

1. **åœæ­¢æ¥æ”¶æ–°è¿æ¥**ï¼šæœåŠ¡å™¨ç«‹å³åœæ­¢ `accept` æ–°çš„ TCP è¿æ¥ã€‚
2. **é€šçŸ¥ç°æœ‰è¿æ¥**ï¼šå‘æ‰€æœ‰æ­£åœ¨å¤„ç†è¯·æ±‚çš„è¿æ¥å‘é€åœæœºä¿¡å·ã€‚
    * å¯¹äº HTTP/1.1ï¼Œä¼šåœ¨å“åº”å¤´æ·»åŠ  `Connection: close`ã€‚
    * å¯¹äº HTTP/2ï¼Œä¼šå‘é€ `GOAWAY` å¸§ã€‚
3. **ç­‰å¾…è¯·æ±‚å®Œæˆ**ï¼šæœåŠ¡å™¨ä¼šç­‰å¾…æ‰€æœ‰æ´»è·ƒè¯·æ±‚å¤„ç†å®Œæ¯•ã€‚
4. **å¼ºåˆ¶è¶…æ—¶**ï¼šå¦‚æœè¶…è¿‡é»˜è®¤çš„ **30ç§’** ä»æœ‰è¯·æ±‚æœªå®Œæˆï¼ŒæœåŠ¡å™¨å°†å¼ºåˆ¶å…³é—­å¹¶é€€å‡ºï¼Œé˜²æ­¢è¿›ç¨‹åƒµæ­»ã€‚

### ç¤ºä¾‹ä»£ç 

ä½ å¯ä»¥ç¼–å†™ä¸€ä¸ªæ¨¡æ‹Ÿæ…¢è¯·æ±‚çš„æ¥å£æ¥æµ‹è¯•æ­¤åŠŸèƒ½ï¼š

```rust
use miko::*;
use miko::macros::*;
use std::time::Duration;

#[get("/slow")]
async fn slow_handler() -> &'static str {
    // æ¨¡æ‹Ÿè€—æ—¶ä»»åŠ¡
    tokio::time::sleep(Duration::from_secs(5)).await;
    "Task Finished!"
}

#[tokio::main]
async fn main() {
    let router = Router::new().get("/slow", slow_handler);

    println!("æŒ‰ Ctrl+C åœæ­¢æœåŠ¡ï¼Œæ­£åœ¨å¤„ç†çš„è¯·æ±‚ä¼šè¢«æ‰§è¡Œå®Œ...");
    Application::new_(router).run().await.unwrap();
}
```

### éªŒè¯æ–¹æ³•

1. å¯åŠ¨æœåŠ¡ã€‚
2. è®¿é—® `/slow` æ¥å£ã€‚
3. ç«‹å³åœ¨ç»ˆç«¯æŒ‰ `Ctrl+C`ã€‚
4. ä½ ä¼šå‘ç°æœåŠ¡æ²¡æœ‰ç«‹å³é€€å‡ºï¼Œè€Œæ˜¯ç­‰å¾… `/slow` è¯·æ±‚è¿”å›ç»“æœåï¼Œæ‰ä¼˜é›…åœ°å…³é—­ã€‚

## Panic æ•è· (Panic Handling)

> **éœ€è¦ `catch_panic` feature**

Miko èƒ½å¤Ÿæ•è·å¤„ç†å‡½æ•°ä¸­å‘ç”Ÿçš„ `panic`ï¼Œé˜²æ­¢æœåŠ¡å´©æºƒå¹¶è¿”å› 500 JSON å“åº”ã€‚

### å¼€å¯æ–¹å¼

#### 1. é€šè¿‡å®å‚æ•° (æ¨è)

åœ¨ `#[miko]` å®ä¸­æ·»åŠ  `catch` å±æ€§ï¼š

```rust
#[miko(catch)]
async fn main() {
   // å…¨å±€ panic æ•è·å·²å¼€å¯
}
```

#### 2. æ‰‹åŠ¨å¼€å¯

å¦‚æœä¸ä½¿ç”¨å®ï¼Œå¯ä»¥æ‰‹åŠ¨ä¸º Router æŒ‚è½½ä¸­é—´ä»¶ï¼š

```rust
let mut router = Router::new();
router.with_catch_panic();
```

### å“åº”æ ¼å¼

ä¸€æ—¦æ•è·åˆ° panicï¼Œå®¢æˆ·ç«¯å°†æ”¶åˆ°å¦‚ä¸‹å“åº”ï¼š

```json
{
   "status": 500,
   "error": "INTERNAL_SERVER_ERROR",
   "message": "Panic occurred: [panic ä¿¡æ¯]",
   "trace_id": "...",
   "timestamp": ...
}
```
