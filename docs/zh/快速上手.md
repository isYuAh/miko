# 快速上手

本教程将帮助你在 5 分钟内上手 Miko 框架，创建你的第一个 Web 应用。

## 前置要求

- Rust 1.75 或更高版本
- Cargo 包管理器

## 创建新项目

```bash
cargo new my-miko-app
cd my-miko-app
```

## 添加依赖

编辑 `Cargo.toml` 文件：

```toml
[dependencies]
miko = { version = "0.3.5", features = ["full"] }
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
```

> **Features 说明**
> - `full`: 启用所有功能，适合快速开始
> - 如需更细粒度的控制，可以只启用需要的 features（参见 [基础概念](基础概念.md#features)）

## Hello World

创建最简单的应用，编辑 `src/main.rs`：

```rust
use miko::*;

// 定义一个简单的处理函数
#[get("/")]
async fn hello() -> &'static str {
    "Hello, Miko!"
}

// 使用 #[miko] 宏自动配置和启动应用（推荐）
#[miko]
async fn main() {
    // router 已自动创建
    // 路由会自动收集并注册
    // 配置会自动加载
}
```

> **`#[miko]` 宏的功能**：
> - 自动展开为 `#[tokio::main]`
> - 自动创建 `router: Router`
> - 自动收集 `#[get]`、`#[post]` 等宏定义的路由并注册（需要 `auto` feature）
> - 自动加载 `config.toml` 并合并 `config.{dev/prod}.toml`
> - 初始化全局依赖容器（需要 `auto` feature）
> - 自动运行应用

运行应用：

```bash
cargo run
```

访问 `http://localhost:8080`，你会看到 "Hello, Miko!"

### 不使用宏的方式

如果不想使用 `#[miko]` 宏，可以手动配置：

```rust
use miko::*;

#[tokio::main]
async fn main() {
    let router = Router::new()
        .get("/", || async { "Hello, Miko!" });
    
    // 不加载配置文件，使用默认配置
    let config = ApplicationConfig::default();
    Application::new(config, router).run().await.unwrap();
}
```

## JSON API

现在让我们创建一个返回 JSON 的 API：

```rust
use miko::{*, extractor::Json};
use serde::{Deserialize, Serialize};

#[derive(Serialize)]
struct Message {
    text: String,
    timestamp: u64,
}

#[get("/api/message")]
async fn get_message() -> Json<Message> {
    Json(Message {
        text: "Hello from Miko!".to_string(),
        timestamp: std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs(),
    })
}

#[miko]
async fn main() {
    // 路由自动注册
}
```

访问 `http://localhost:8080/api/message`，你会得到 JSON 响应。

## 处理请求数据

### 路径参数

```rust
use miko::{*, extractor::{Json, Path}};

#[derive(Serialize)]
struct User {
    id: u32,
    name: String,
}

#[get("/users/{id}")]
async fn get_user(Path(id): Path<u32>) -> Json<User> {
    Json(User {
        id,
        name: format!("User {}", id),
    })
}
```

访问 `http://localhost:8080/users/123`

### 查询参数

```rust
use std::collections::HashMap;
use miko::{*, extractor::Query};

#[derive(Deserialize)]
struct QueryStruct {
  q: String
}

#[get("/search")]
async fn search(Query(params): Query<QueryStruct>) -> String {
    let keyword = params.q;
    format!("Searching for: {}", keyword)
}
```

访问 `http://localhost:8080/search?q=rust`

### POST 请求体

```rust
#[derive(Deserialize)]
struct CreateUser {
    name: String,
    email: String,
}

#[derive(Serialize)]
struct UserResponse {
    id: u32,
    name: String,
    email: String,
}

#[post("/users")]
async fn create_user(Json(data): Json<CreateUser>) -> Json<UserResponse> {
    Json(UserResponse {
        id: 1,
        name: data.name,
        email: data.email,
    })
}
```

测试：

```bash
curl -X POST http://localhost:8080/users \
  -H "Content-Type: application/json" \
  -d '{"name":"Alice","email":"alice@example.com"}'
```

## 完整示例

一个包含多个路由的完整应用：

```rust
use miko::{*, extractor::{Json, Path, Query}};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Serialize)]
struct User {
    id: u32,
    name: String,
    email: String,
}

#[derive(Deserialize)]
struct CreateUser {
    name: String,
    email: String,
}

// 首页
#[get("/")]
async fn index() -> &'static str {
    "Welcome to Miko API!"
}

#[derive(serde::Deserialize)]
struct ListQuery {
  limit: Option<usize>,
}

#[get("/users")]
async fn list_users(Query(params): Query<ListQuery>) -> Json<Vec<User>> {
  let limit = params.limit.unwrap_or(10) as u32;
  let users: Vec<User> = (1..=limit)
    .map(|id| User {
      id,
      name: format!("User {}", id),
      email: format!("user{}@example.com", id),
    })
    .collect();
  Json(users)
}

// 获取单个用户
#[get("/users/{id}")]
async fn get_user(Path(id): Path<u32>) -> Json<User> {
    Json(User {
        id,
        name: format!("User {}", id),
        email: format!("user{}@example.com", id),
    })
}

// 创建用户
#[post("/users")]
async fn create_user(Json(data): Json<CreateUser>) -> Json<User> {
    Json(User {
        id: 999,
        name: data.name,
        email: data.email,
    })
}

#[miko]
async fn main() {
    // 所有路由自动注册
}
```

## 测试 API

```bash
# 访问首页
curl http://localhost:8080/

# 获取用户列表
curl http://localhost:8080/users

# 获取用户列表（限制数量）
curl http://localhost:8080/users?limit=5

# 获取单个用户
curl http://localhost:8080/users/1

# 创建用户
curl -X POST http://localhost:8080/users \
  -H "Content-Type: application/json" \
  -d '{"name":"Alice","email":"alice@example.com"}'
```

## 配置服务器

默认情况下，Miko 监听 `0.0.0.0:8080`。你可以通过配置文件修改：

创建 `config.toml`：

```toml
[application]
addr = "127.0.0.1"
port = 9999
```

`#[miko]` 宏会自动加载配置。在开发环境（debug 模式）中，如果存在 `config.dev.toml`，它会与 `config.toml` 合并；在生产环境（release 模式）中会使用 `config.prod.toml`。

更多配置选项请参见 [配置管理](配置管理.md)。

## 下一步

恭喜！你已经掌握了 Miko 的基础用法。接下来你可以：

- 📖 阅读 [基础概念](基础概念.md) 深入了解框架架构
- 🛣️ 学习 [路由系统](路由系统.md) 的高级用法
- 🔍 探索 [错误处理](错误处理.md) 机制
- 💉 使用 [依赖注入](依赖注入.md) 管理组件
- 📝 集成 [OpenAPI](OpenAPI集成.md) 生成文档
- ✅ 添加 [数据验证](数据验证.md)

查看 `miko/examples/` 目录获取更多完整示例。
