# 配置管理

Miko 提供了基于 TOML 的配置系统，支持环境区分和配置注入。

## 配置文件

### 基础配置

在项目根目录创建 `config.toml`：

```toml
[application]
addr = "0.0.0.0"
port = 8080

[database]
url = "postgres://localhost/mydb"
max_connections = 10

[redis]
url = "redis://localhost"
timeout = 5

[app]
name = "My Application"
version = "1.0.0"
debug = false
```

### 环境配置

Miko 支持环境特定的配置文件：

- `config.dev.toml` - 开发环境（debug 模式）
- `config.prod.toml` - 生产环境（release 模式）

环境配置会自动与基础配置合并，环境配置优先级更高。

**config.dev.toml**：

```toml
[application]
port = 3000

[app]
debug = true
```

**config.prod.toml**：

```toml
[database]
url = "postgres://prod-server/mydb"
max_connections = 50

[app]
debug = false
```

## 自动加载

使用 `#[miko]` 宏时配置会自动加载：

```rust
use miko::*;

#[get("/")]
async fn index() -> &'static str {
    "Hello"
}

#[miko]
async fn main() {
    // 配置已自动加载
    // router 可用
}
```

`#[miko]` 宏会：
1. 加载 `config.toml`
2. 根据编译模式合并 `config.dev.toml` 或 `config.prod.toml`
3. 将配置存储到全局变量

## 手动加载

如果不使用 `#[miko]` 宏，有两种方式手动加载配置：

### 方式 1: 使用 `Application::new_`（推荐）

`Application::new_` 会自动加载配置文件：

```rust
use miko::{Router, Application};

#[tokio::main]
async fn main() {
    let router = Router::new()
        .get("/", handler);
    
    // 自动加载 config.toml 和环境配置
    Application::new_(router).run().await.unwrap();
}
```

### 方式 2: 手动加载配置

如果需要在创建应用前访问配置：

```rust
use miko::app::config::ApplicationConfig;
use miko::{Router, Application};

#[tokio::main]
async fn main() {
    // 手动加载配置
    let config = ApplicationConfig::load_().unwrap_or_default();
    
    println!("Starting on port {}", config.port);
    
    let router = Router::new()
        .get("/", handler);
    
    Application::new(config, router).run().await.unwrap();
}
```

## 在 Handler 中使用配置

### 使用 `#[config]` 注解

直接注入配置值到 Handler 参数：

```rust
#[get("/info")]
async fn app_info(
    #[config("app.name")] app_name: String,
    #[config("app.version")] version: String,
    #[config("app.debug")] debug: bool,
) -> Json<serde_json::Value> {
    Json(json!({
        "name": app_name,
        "version": version,
        "debug": debug
    }))
}
```

### 配置路径

使用点号分隔的路径访问嵌套配置：

```toml
[database]
host = "localhost"
port = 5432

[database.pool]
min = 5
max = 20
```

```rust
#[get("/db-config")]
async fn db_config(
    #[config("database.host")] host: String,
    #[config("database.port")] port: u16,
    #[config("database.pool.max")] max_connections: u32,
) -> String {
    format!("DB: {}:{}, Max: {}", host, port, max_connections)
}
```

### 支持的类型

`#[config]` 支持所有实现 `serde::Deserialize` 的类型:

```rust
// 基础类型
#[config("port")] port: u16
#[config("debug")] debug: bool
#[config("name")] name: String
#[config("timeout")] timeout: f64

// 集合类型
#[config("allowed_origins")] origins: Vec<String>
#[config("features")] features: HashMap<String, bool>

// 自定义结构体
#[derive(Deserialize)]
struct DatabaseConfig {
    host: String,
    port: u16,
    database: String,
}

#[get("/db-config")]
async fn db_config(
    #[config("database")] db_config: DatabaseConfig
) -> String {
    format!("{}:{}/{}", db_config.host, db_config.port, db_config.database)
}

// 可选类型
#[get("/optional")]
async fn optional_config(
    #[config("features.beta")] beta: Option<bool>
) -> String {
    format!("Beta enabled: {}", beta.unwrap_or(false))
}
```

## 程序化访问配置

### 获取配置节

```rust
use miko::app::config::load_config_section;
use serde::Deserialize;

#[derive(Deserialize)]
struct DatabaseConfig {
    url: String,
    max_connections: u32,
}

async fn init_db() -> Result<Database, Error> {
    let config: DatabaseConfig = load_config_section("database")?;
    Database::connect(&config.url).await
}
```

### 获取完整配置

```rust
use miko::app::config::get_config;
use toml::Value;

fn get_feature_flag(name: &str) -> bool {
    let config = get_config();
    config.get("features")
        .and_then(|f| f.get(name))
        .and_then(|v| v.as_bool())
        .unwrap_or(false)
}
```


## 下一步

- 💉 使用 [依赖注入](依赖注入.md) 管理组件
- 🔍 了解 [请求提取器](请求提取器.md) 的用法
- 📖 查看 [基础概念](基础概念.md) 理解架构
