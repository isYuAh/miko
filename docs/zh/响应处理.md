# 响应处理

Miko 通过 `IntoResponse` trait 提供灵活的响应处理机制，让你可以用多种方式构建 HTTP 响应。

## IntoResponse Trait

任何实现了 `IntoResponse` 的类型都可以作为 Handler 的返回值：

```rust
pub trait IntoResponse {
    fn into_response(self) -> Response;
}
```

框架为常用类型提供了实现，你也可以为自定义类型实现这个 trait。

## 基础响应类型

### 字符串响应

最简单的响应方式：

```rust
#[get("/text")]
async fn text() -> &'static str {
    "Hello, World!"
}

#[get("/owned")]
async fn owned_text() -> String {
    format!("Generated at: {}", chrono::Utc::now())
}
```

默认 Content-Type 为 `text/plain`。

### JSON 响应

返回 JSON 数据：

```rust
use miko::{*, extractor::Json};
use miko::macros::*;
use serde::Serialize;

#[derive(Serialize)]
struct User {
    id: u32,
    name: String,
    email: String,
}

#[get("/users/{id}")]
async fn get_user(#[path] id: u32) -> Json<User> {
    Json(User {
        id,
        name: "Alice".into(),
        email: "alice@example.com".into(),
    })
}
```

自动设置 `Content-Type: application/json`。

### HTML 响应

返回 HTML 内容：

```rust
use miko::http::response::into_response::Html;

#[get("/page")]
async fn page() -> Html {
    Html("<html><body><h1>Hello</h1></body></html>".into())
}

#[get("/template")]
async fn template() -> Html {
    let content = format!(
        r#"
        <!DOCTYPE html>
        <html>
        <head><title>My Page</title></head>
        <body>
            <h1>Welcome</h1>
            <p>Current time: {}</p>
        </body>
        </html>
        "#,
        chrono::Utc::now()
    );
    Html(content)
}
```

自动设置 `Content-Type: text/html; charset=utf-8`。

## 状态码

### 使用元组返回状态码

```rust
use hyper::StatusCode;

// 201 Created
#[post("/users")]
async fn create_user(Json(data): Json<CreateUser>) -> (StatusCode, Json<User>) {
    let user = create_user_in_db(data);
    (StatusCode::CREATED, Json(user))
}

// 204 No Content
#[delete("/users/{id}")]
async fn delete_user(#[path] id: u32) -> StatusCode {
    delete_user_from_db(id);
    StatusCode::NO_CONTENT
}

// 自定义状态码
#[get("/custom")]
async fn custom() -> (StatusCode, &'static str) {
    (StatusCode::IM_A_TEAPOT, "I'm a teapot!")
}
```

### 常用状态码

```rust
StatusCode::OK                    // 200
StatusCode::CREATED               // 201
StatusCode::ACCEPTED              // 202
StatusCode::NO_CONTENT            // 204
StatusCode::MOVED_PERMANENTLY     // 301
StatusCode::FOUND                 // 302
StatusCode::BAD_REQUEST           // 400
StatusCode::UNAUTHORIZED          // 401
StatusCode::FORBIDDEN             // 403
StatusCode::NOT_FOUND             // 404
StatusCode::INTERNAL_SERVER_ERROR // 500
```

## 响应头

### 使用元组添加响应头

```rust
use hyper::HeaderMap;

#[get("/with-headers")]
async fn with_headers() -> (HeaderMap, Json<User>) {
    let mut headers = HeaderMap::new();
    headers.insert("X-Custom-Header", "value".parse().unwrap());
    headers.insert("X-Request-Id", "123456".parse().unwrap());

    (headers, Json(user))
}
```

### 组合状态码和响应头

```rust
#[post("/users")]
async fn create_with_headers() -> (StatusCode, HeaderMap, Json<User>) {
    let mut headers = HeaderMap::new();
    headers.insert("Location", "/users/123".parse().unwrap());

    (StatusCode::CREATED, headers, Json(user))
}
```

## Result 类型

### 使用 AppResult

推荐使用框架提供的 `AppResult` 类型：

```rust
use miko::{AppResult, AppError};

#[get("/users/{id}")]
async fn get_user(#[path] id: u32) -> AppResult<Json<User>> {
    let user = db.find_user(id)
        .ok_or(AppError::NotFound(format!("User {} not found", id)))?;

    Ok(Json(user))
}

#[post("/users")]
async fn create_user(Json(data): Json<CreateUser>) -> AppResult<Json<User>> {
    // 验证
    if data.email.is_empty() {
        return Err(AppError::BadRequest("Email is required".into()));
    }

    // 检查重复
    if db.email_exists(&data.email) {
        return Err(AppError::Conflict("Email already exists".into()));
    }

    let user = db.create_user(data)?;
    Ok(Json(user))
}
```

错误会自动转换为 JSON 响应。详见 [错误处理](错误处理.md)。

### Result 与状态码

```rust
#[post("/users")]
async fn create_user(
    Json(data): Json<CreateUser>
) -> AppResult<(StatusCode, Json<User>)> {
    let user = db.create_user(data)?;
    Ok((StatusCode::CREATED, Json(user)))
}
```

## Server-Sent Events (SSE)

实时推送数据到客户端：

> **SSE 功能需要在 `#[miko]` 宏中添加 `sse` 参数**：`#[miko(sse)]`
> 不添加也行，只不过用户端提前关闭连接会panic，从而导致有很多输出
> sse参数的功能主要是应用一个panic hook忽略此错误
> 如果你没使用`#[miko]`，你可以使用`set_sse_panic_hook()`

```rust
use miko::http::response::sse::SseSender;
use std::time::Duration;

// 我们为接收SseSender的闭包实现了IntoResponse，或者你也可以使用spawn_sse_event()
#[get("/events")]
async fn events() {
    |sender: SseSender| async move {
        // 发送消息 （我们使用了IntoMessage trait）
        sender.send("Connected").await.or_break();

        // 定期推送
        for i in 1..=10 {
            tokio::time::sleep(Duration::from_secs(1)).await;
            sender.send(format!("Event {}", i)).await.or_break();
        }

        // 发送 JSON
        sender.send(Json(MyData { value: 42 })).await.or_break();

        sender.send("Done").await.or_break();
    }
}
```

### SSE 事件格式

```rust
use miko::http::response::sse::{SseEvent, SseSender};

#[get("/custom-events")]
async fn custom_events() {
    |sender: SseSender| async move {
        // 自定义事件
        sender.event(
            "greeting", //event 名称
            SseEvent::data("Hello") // 同样的 IntoMessage
                .id("msg-1")
                .retry(3000)
        ).await.or_break();

        // 简单消息
        sender.send("Simple message").await.or_break();
    }
}
```

### 客户端示例

```javascript
const eventSource = new EventSource('/events');

eventSource.onmessage = (event) => {
    console.log('Received:', event.data);
};

eventSource.addEventListener('greeting', (event) => {
    console.log('Greeting:', event.data);
});

eventSource.onerror = (error) => {
    console.error('Error:', error);
    eventSource.close();
};
```

### 断开处理

使用 `.or_break()` 在客户端断开时优雅退出（之前提到的panic_hook就是拦截这个的）：

```rust
#[get("/stream")]
async fn stream() {
    |sender: SseSender| async move {
        loop {
            tokio::time::sleep(Duration::from_secs(1)).await;

            // 如果客户端断开，or_break() 会终止任务
            sender.send("data").await.or_break();
        }
    }
}
```

## 文件响应

### 流式文件下载

使用流式响应避免将整个文件加载到内存：

```rust
use tokio::fs::File;
use tokio_util::io::ReaderStream;
use miko_core::fallible_stream_body::FallibleStreamBody;
use hyper::Response;
use bytes::Bytes;

#[get("/download/{filename}")]
async fn download_file(#[path] filename: String) -> AppResult<Response<BoxBody<Bytes, std::io::Error>>> {
    let path = format!("./uploads/{}", filename);
    let file = File::open(&path).await?;
    let metadata = file.metadata().await?;

    let stream = ReaderStream::new(file);
    let body = FallibleStreamBody::with_size_hint(stream, metadata.len());

    Ok(Response::builder()
        .status(200)
        .header("Content-Type", "application/octet-stream")
        .header("Content-Disposition", format!("attachment; filename=\"{}\"", filename))
        .body(body.boxed())
        .unwrap())
}
```

### 小文件响应

对于小文件可以直接读取：

```rust
use bytes::Bytes;
use http_body_util::Full;

#[get("/image/{id}")]
async fn get_image(#[path] id: u32) -> AppResult<Response<BoxBody<Bytes, Infallible>>> {
    let data = tokio::fs::read(format!("./images/{}.jpg", id)).await?;

    Ok(Response::builder()
        .header("Content-Type", "image/jpeg")
        .body(Full::new(Bytes::from(data)).boxed())
        .unwrap())
}
```

> **提示**: 对于完整的静态文件服务功能，推荐使用 `StaticSvc`，详见 [高级特性 - 静态文件服务](高级特性.md#静态文件服务)。

## 重定向

```rust
use hyper::StatusCode;

#[get("/old-path")]
async fn redirect() -> (StatusCode, HeaderMap, &'static str) {
    let mut headers = HeaderMap::new();
    headers.insert("Location", "/new-path".parse().unwrap());

    (StatusCode::MOVED_PERMANENTLY, headers, "Redirecting...")
}

// 或使用 FOUND (302)
#[get("/temp-redirect")]
async fn temp_redirect() -> (StatusCode, HeaderMap) {
    let mut headers = HeaderMap::new();
    headers.insert("Location", "/new-location".parse().unwrap());

    (StatusCode::FOUND, headers)
}
```

## 流式响应

返回数据流：

```rust
use futures::stream;
use bytes::Bytes;

#[get("/stream")]
async fn stream_response() -> impl IntoResponse {
    let stream = stream::iter(vec![
        Ok::<_, std::io::Error>(Bytes::from("chunk1\n")),
        Ok(Bytes::from("chunk2\n")),
        Ok(Bytes::from("chunk3\n")),
    ]);

    // 使用 SSE 包装器或自定义实现
    // ...
}
```

## 自定义响应类型

为自己的类型实现 `IntoResponse`：

```rust
use miko::http::response::into_response::IntoResponse;
use hyper::{Response, StatusCode};
use bytes::Bytes;
use http_body_util::Full;

struct ApiResponse<T> {
    code: i32,
    message: String,
    data: Option<T>,
}

impl<T: Serialize> IntoResponse for ApiResponse<T> {
    fn into_response(self) -> Response<BoxBody<Bytes, Infallible>> {
        let body = serde_json::json!({
            "code": self.code,
            "message": self.message,
            "data": self.data,
        });

        let bytes = serde_json::to_vec(&body).unwrap();

        Response::builder()
            .status(StatusCode::OK)
            .header("Content-Type", "application/json")
            .body(Full::new(Bytes::from(bytes)).boxed())
            .unwrap()
    }
}

// 使用自定义响应
#[get("/api/users/{id}")]
async fn get_user(#[path] id: u32) -> ApiResponse<User> {
    ApiResponse {
        code: 0,
        message: "Success".into(),
        data: Some(user),
    }
}
```

## 空响应

### 返回状态码（无内容）

直接返回 `StatusCode` 会生成空响应体：

```rust
// 204 No Content
#[delete("/users/{id}")]
async fn delete_user(#[path] id: u32) -> StatusCode {
    // 执行删除操作
    StatusCode::NO_CONTENT
}

// 202 Accepted
#[post("/tasks")]
async fn create_task(Json(data): Json<Task>) -> StatusCode {
    // 提交异步任务
    StatusCode::ACCEPTED
}
```

### 返回单元类型

```rust
// 返回单元类型 - 默认 200 OK
#[post("/notify")]
async fn notify() -> () {
    // 发送通知
}
```

## 响应构建器

使用 Hyper 的响应构建器：

```rust
use hyper::Response;
use bytes::Bytes;
use http_body_util::Full;

#[get("/custom")]
async fn custom_response() -> Response<BoxBody<Bytes, Infallible>> {
    Response::builder()
        .status(StatusCode::OK)
        .header("X-Custom", "value")
        .header("Content-Type", "text/plain")
        .body(Full::new(Bytes::from("Custom response")).boxed())
        .unwrap()
}
```

## 条件响应

根据条件返回不同响应：

```rust
#[get("/users/{id}")]
async fn get_user_conditional(
    #[path] id: u32,
    headers: HeaderMap,
) -> impl IntoResponse {
    let user = db.find_user(id);

    match user {
        Some(u) if headers.contains_key("X-Include-Details") => {
            // 返回详细信息
            Json(UserDetail::from(u)).into_response()
        }
        Some(u) => {
            // 返回基本信息
            Json(UserBasic::from(u)).into_response()
        }
        None => {
            // 返回 404
            StatusCode::NOT_FOUND.into_response()
        }
    }
}
```

## 完整示例

```rust
use miko::{*, extractor::{Json, Path},
use miko::macros::*;
http::response::into_response::Html};
use serde::{Deserialize, Serialize};
use hyper::{StatusCode, HeaderMap};

#[derive(Serialize, Deserialize)]
struct Post {
    id: u32,
    title: String,
    content: String,
}

#[derive(Deserialize)]
struct CreatePost {
    title: String,
    content: String,
}

// 文本响应
#[get("/")]
async fn index() -> &'static str {
    "Welcome to Blog API"
}

// HTML 响应
#[get("/page")]
async fn page() -> Html {
    Html("<h1>My Blog</h1>".into())
}

// JSON 响应
#[get("/posts")]
async fn list_posts() -> Json<Vec<Post>> {
    Json(vec![
        Post { id: 1, title: "First".into(), content: "...".into() }
    ])
}

// 带状态码的 JSON
#[post("/posts")]
async fn create_post(
    Json(data): Json<CreatePost>
) -> (StatusCode, Json<Post>) {
    let post = Post {
        id: 1,
        title: data.title,
        content: data.content,
    };
    (StatusCode::CREATED, Json(post))
}

// Result 类型
#[get("/posts/{id}")]
async fn get_post(#[path] id: u32) -> AppResult<Json<Post>> {
    let post = db.find_post(id)
        .ok_or(AppError::NotFound("Post not found".into()))?;
    Ok(Json(post))
}

// 带响应头
#[put("/posts/{id}")]
async fn update_post(
    #[path] id: u32,
    Json(data): Json<CreatePost>,
) -> AppResult<(HeaderMap, Json<Post>)> {
    let post = db.update_post(id, data)?;

    let mut headers = HeaderMap::new();
    headers.insert("X-Updated-At", chrono::Utc::now().to_string().parse().unwrap());

    Ok((headers, Json(post)))
}

// 删除 - 无内容
#[delete("/posts/{id}")]
async fn delete_post(#[path] id: u32) -> AppResult<StatusCode> {
    db.delete_post(id)?;
    Ok(StatusCode::NO_CONTENT)
}

// SSE 示例
#[get("/events")]
async fn events() {
    |sender: SseSender| async move {
        for i in 1..=5 {
            tokio::time::sleep(Duration::from_secs(1)).await;
            sender.send(format!("Event {}", i)).await.or_break();
        }
    }
}

#[miko(sse)]  // 启用 SSE 支持
async fn main() {
    println!("🚀 Blog API running");
}
```

## 下一步

- ⚠️ 学习 [错误处理](错误处理.md) 机制
- 🔍 了解 [请求提取器](请求提取器.md) 的用法
- 🌐 探索 [WebSocket](WebSocket支持.md) 双向通信
