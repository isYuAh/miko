# å“åº”å¤„ç†

Miko é€šè¿‡ `IntoResponse` trait æä¾›çµæ´»çš„å“åº”å¤„ç†æœºåˆ¶ï¼Œè®©ä½ å¯ä»¥ç”¨å¤šç§æ–¹å¼æ„å»º HTTP å“åº”ã€‚

## IntoResponse Trait

ä»»ä½•å®ç°äº† `IntoResponse` çš„ç±»å‹éƒ½å¯ä»¥ä½œä¸º Handler çš„è¿”å›å€¼ï¼š

```rust
pub trait IntoResponse {
    fn into_response(self) -> Response;
}
```

æ¡†æ¶ä¸ºå¸¸ç”¨ç±»å‹æä¾›äº†å®ç°ï¼Œä½ ä¹Ÿå¯ä»¥ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç°è¿™ä¸ª traitã€‚

## åŸºç¡€å“åº”ç±»å‹

### å­—ç¬¦ä¸²å“åº”

æœ€ç®€å•çš„å“åº”æ–¹å¼ï¼š

```rust
#[get("/text")]
async fn text() -> &'static str {
    "Hello, World!"
}

#[get("/owned")]
async fn owned_text() -> String {
    format!("Generated at: {}", chrono::Utc::now())
}
```

é»˜è®¤ Content-Type ä¸º `text/plain`ã€‚

### JSON å“åº”

è¿”å› JSON æ•°æ®ï¼š

```rust
use miko::{*, extractor::Json};
use miko::macros::*;
use serde::Serialize;

#[derive(Serialize)]
struct User {
    id: u32,
    name: String,
    email: String,
}

#[get("/users/{id}")]
async fn get_user(#[path] id: u32) -> Json<User> {
    Json(User {
        id,
        name: "Alice".into(),
        email: "alice@example.com".into(),
    })
}
```

è‡ªåŠ¨è®¾ç½® `Content-Type: application/json`ã€‚

### HTML å“åº”

è¿”å› HTML å†…å®¹ï¼š

```rust
use miko::http::response::into_response::Html;

#[get("/page")]
async fn page() -> Html {
    Html("<html><body><h1>Hello</h1></body></html>".into())
}

#[get("/template")]
async fn template() -> Html {
    let content = format!(
        r#"
        <!DOCTYPE html>
        <html>
        <head><title>My Page</title></head>
        <body>
            <h1>Welcome</h1>
            <p>Current time: {}</p>
        </body>
        </html>
        "#,
        chrono::Utc::now()
    );
    Html(content)
}
```

è‡ªåŠ¨è®¾ç½® `Content-Type: text/html; charset=utf-8`ã€‚

## çŠ¶æ€ç 

### ä½¿ç”¨å…ƒç»„è¿”å›çŠ¶æ€ç 

```rust
use hyper::StatusCode;

// 201 Created
#[post("/users")]
async fn create_user(Json(data): Json<CreateUser>) -> (StatusCode, Json<User>) {
    let user = create_user_in_db(data);
    (StatusCode::CREATED, Json(user))
}

// 204 No Content
#[delete("/users/{id}")]
async fn delete_user(#[path] id: u32) -> StatusCode {
    delete_user_from_db(id);
    StatusCode::NO_CONTENT
}

// è‡ªå®šä¹‰çŠ¶æ€ç 
#[get("/custom")]
async fn custom() -> (StatusCode, &'static str) {
    (StatusCode::IM_A_TEAPOT, "I'm a teapot!")
}
```

### å¸¸ç”¨çŠ¶æ€ç 

```rust
StatusCode::OK                    // 200
StatusCode::CREATED               // 201
StatusCode::ACCEPTED              // 202
StatusCode::NO_CONTENT            // 204
StatusCode::MOVED_PERMANENTLY     // 301
StatusCode::FOUND                 // 302
StatusCode::BAD_REQUEST           // 400
StatusCode::UNAUTHORIZED          // 401
StatusCode::FORBIDDEN             // 403
StatusCode::NOT_FOUND             // 404
StatusCode::INTERNAL_SERVER_ERROR // 500
```

## å“åº”å¤´

### ä½¿ç”¨å…ƒç»„æ·»åŠ å“åº”å¤´

```rust
use hyper::HeaderMap;

#[get("/with-headers")]
async fn with_headers() -> (HeaderMap, Json<User>) {
    let mut headers = HeaderMap::new();
    headers.insert("X-Custom-Header", "value".parse().unwrap());
    headers.insert("X-Request-Id", "123456".parse().unwrap());

    (headers, Json(user))
}
```

### ç»„åˆçŠ¶æ€ç å’Œå“åº”å¤´

```rust
#[post("/users")]
async fn create_with_headers() -> (StatusCode, HeaderMap, Json<User>) {
    let mut headers = HeaderMap::new();
    headers.insert("Location", "/users/123".parse().unwrap());

    (StatusCode::CREATED, headers, Json(user))
}
```

## Result ç±»å‹

### ä½¿ç”¨ AppResult

æ¨èä½¿ç”¨æ¡†æ¶æä¾›çš„ `AppResult` ç±»å‹ï¼š

```rust
use miko::{AppResult, AppError};

#[get("/users/{id}")]
async fn get_user(#[path] id: u32) -> AppResult<Json<User>> {
    let user = db.find_user(id)
        .ok_or(AppError::NotFound(format!("User {} not found", id)))?;

    Ok(Json(user))
}

#[post("/users")]
async fn create_user(Json(data): Json<CreateUser>) -> AppResult<Json<User>> {
    // éªŒè¯
    if data.email.is_empty() {
        return Err(AppError::BadRequest("Email is required".into()));
    }

    // æ£€æŸ¥é‡å¤
    if db.email_exists(&data.email) {
        return Err(AppError::Conflict("Email already exists".into()));
    }

    let user = db.create_user(data)?;
    Ok(Json(user))
}
```

é”™è¯¯ä¼šè‡ªåŠ¨è½¬æ¢ä¸º JSON å“åº”ã€‚è¯¦è§ [é”™è¯¯å¤„ç†](é”™è¯¯å¤„ç†.md)ã€‚

### Result ä¸çŠ¶æ€ç 

```rust
#[post("/users")]
async fn create_user(
    Json(data): Json<CreateUser>
) -> AppResult<(StatusCode, Json<User>)> {
    let user = db.create_user(data)?;
    Ok((StatusCode::CREATED, Json(user)))
}
```

## Server-Sent Events (SSE)

å®æ—¶æ¨é€æ•°æ®åˆ°å®¢æˆ·ç«¯ï¼š

> **SSE åŠŸèƒ½éœ€è¦åœ¨ `#[miko]` å®ä¸­æ·»åŠ  `sse` å‚æ•°**ï¼š`#[miko(sse)]`
> ä¸æ·»åŠ ä¹Ÿè¡Œï¼Œåªä¸è¿‡ç”¨æˆ·ç«¯æå‰å…³é—­è¿æ¥ä¼španicï¼Œä»è€Œå¯¼è‡´æœ‰å¾ˆå¤šè¾“å‡º
> sseå‚æ•°çš„åŠŸèƒ½ä¸»è¦æ˜¯åº”ç”¨ä¸€ä¸ªpanic hookå¿½ç•¥æ­¤é”™è¯¯
> å¦‚æœä½ æ²¡ä½¿ç”¨`#[miko]`ï¼Œä½ å¯ä»¥ä½¿ç”¨`set_sse_panic_hook()`

```rust
use miko::http::response::sse::SseSender;
use std::time::Duration;

// æˆ‘ä»¬ä¸ºæ¥æ”¶SseSenderçš„é—­åŒ…å®ç°äº†IntoResponseï¼Œæˆ–è€…ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨spawn_sse_event()
#[get("/events")]
async fn events() {
    |sender: SseSender| async move {
        // å‘é€æ¶ˆæ¯ ï¼ˆæˆ‘ä»¬ä½¿ç”¨äº†IntoMessage traitï¼‰
        sender.send("Connected").await.or_break();

        // å®šæœŸæ¨é€
        for i in 1..=10 {
            tokio::time::sleep(Duration::from_secs(1)).await;
            sender.send(format!("Event {}", i)).await.or_break();
        }

        // å‘é€ JSON
        sender.send(Json(MyData { value: 42 })).await.or_break();

        sender.send("Done").await.or_break();
    }
}
```

### SSE äº‹ä»¶æ ¼å¼

```rust
use miko::http::response::sse::{SseEvent, SseSender};

#[get("/custom-events")]
async fn custom_events() {
    |sender: SseSender| async move {
        // è‡ªå®šä¹‰äº‹ä»¶
        sender.event(
            "greeting", //event åç§°
            SseEvent::data("Hello") // åŒæ ·çš„ IntoMessage
                .id("msg-1")
                .retry(3000)
        ).await.or_break();

        // ç®€å•æ¶ˆæ¯
        sender.send("Simple message").await.or_break();
    }
}
```

### å®¢æˆ·ç«¯ç¤ºä¾‹

```javascript
const eventSource = new EventSource('/events');

eventSource.onmessage = (event) => {
    console.log('Received:', event.data);
};

eventSource.addEventListener('greeting', (event) => {
    console.log('Greeting:', event.data);
});

eventSource.onerror = (error) => {
    console.error('Error:', error);
    eventSource.close();
};
```

### æ–­å¼€å¤„ç†

ä½¿ç”¨ `.or_break()` åœ¨å®¢æˆ·ç«¯æ–­å¼€æ—¶ä¼˜é›…é€€å‡ºï¼ˆä¹‹å‰æåˆ°çš„panic_hookå°±æ˜¯æ‹¦æˆªè¿™ä¸ªçš„ï¼‰ï¼š

```rust
#[get("/stream")]
async fn stream() {
    |sender: SseSender| async move {
        loop {
            tokio::time::sleep(Duration::from_secs(1)).await;

            // å¦‚æœå®¢æˆ·ç«¯æ–­å¼€ï¼Œor_break() ä¼šç»ˆæ­¢ä»»åŠ¡
            sender.send("data").await.or_break();
        }
    }
}
```

## æ–‡ä»¶å“åº”

### æµå¼æ–‡ä»¶ä¸‹è½½

ä½¿ç”¨æµå¼å“åº”é¿å…å°†æ•´ä¸ªæ–‡ä»¶åŠ è½½åˆ°å†…å­˜ï¼š

```rust
use tokio::fs::File;
use tokio_util::io::ReaderStream;
use miko_core::fallible_stream_body::FallibleStreamBody;
use hyper::Response;
use bytes::Bytes;

#[get("/download/{filename}")]
async fn download_file(#[path] filename: String) -> AppResult<Response<BoxBody<Bytes, std::io::Error>>> {
    let path = format!("./uploads/{}", filename);
    let file = File::open(&path).await?;
    let metadata = file.metadata().await?;

    let stream = ReaderStream::new(file);
    let body = FallibleStreamBody::with_size_hint(stream, metadata.len());

    Ok(Response::builder()
        .status(200)
        .header("Content-Type", "application/octet-stream")
        .header("Content-Disposition", format!("attachment; filename=\"{}\"", filename))
        .body(body.boxed())
        .unwrap())
}
```

### å°æ–‡ä»¶å“åº”

å¯¹äºå°æ–‡ä»¶å¯ä»¥ç›´æ¥è¯»å–ï¼š

```rust
use bytes::Bytes;
use http_body_util::Full;

#[get("/image/{id}")]
async fn get_image(#[path] id: u32) -> AppResult<Response<BoxBody<Bytes, Infallible>>> {
    let data = tokio::fs::read(format!("./images/{}.jpg", id)).await?;

    Ok(Response::builder()
        .header("Content-Type", "image/jpeg")
        .body(Full::new(Bytes::from(data)).boxed())
        .unwrap())
}
```

> **æç¤º**: å¯¹äºå®Œæ•´çš„é™æ€æ–‡ä»¶æœåŠ¡åŠŸèƒ½ï¼Œæ¨èä½¿ç”¨ `StaticSvc`ï¼Œè¯¦è§ [é«˜çº§ç‰¹æ€§ - é™æ€æ–‡ä»¶æœåŠ¡](é«˜çº§ç‰¹æ€§.md#é™æ€æ–‡ä»¶æœåŠ¡)ã€‚

## é‡å®šå‘

```rust
use hyper::StatusCode;

#[get("/old-path")]
async fn redirect() -> (StatusCode, HeaderMap, &'static str) {
    let mut headers = HeaderMap::new();
    headers.insert("Location", "/new-path".parse().unwrap());

    (StatusCode::MOVED_PERMANENTLY, headers, "Redirecting...")
}

// æˆ–ä½¿ç”¨ FOUND (302)
#[get("/temp-redirect")]
async fn temp_redirect() -> (StatusCode, HeaderMap) {
    let mut headers = HeaderMap::new();
    headers.insert("Location", "/new-location".parse().unwrap());

    (StatusCode::FOUND, headers)
}
```

## æµå¼å“åº”

è¿”å›æ•°æ®æµï¼š

```rust
use futures::stream;
use bytes::Bytes;

#[get("/stream")]
async fn stream_response() -> impl IntoResponse {
    let stream = stream::iter(vec![
        Ok::<_, std::io::Error>(Bytes::from("chunk1\n")),
        Ok(Bytes::from("chunk2\n")),
        Ok(Bytes::from("chunk3\n")),
    ]);

    // ä½¿ç”¨ SSE åŒ…è£…å™¨æˆ–è‡ªå®šä¹‰å®ç°
    // ...
}
```

## è‡ªå®šä¹‰å“åº”ç±»å‹

ä¸ºè‡ªå·±çš„ç±»å‹å®ç° `IntoResponse`ï¼š

```rust
use miko::http::response::into_response::IntoResponse;
use hyper::{Response, StatusCode};
use bytes::Bytes;
use http_body_util::Full;

struct ApiResponse<T> {
    code: i32,
    message: String,
    data: Option<T>,
}

impl<T: Serialize> IntoResponse for ApiResponse<T> {
    fn into_response(self) -> Response<BoxBody<Bytes, Infallible>> {
        let body = serde_json::json!({
            "code": self.code,
            "message": self.message,
            "data": self.data,
        });

        let bytes = serde_json::to_vec(&body).unwrap();

        Response::builder()
            .status(StatusCode::OK)
            .header("Content-Type", "application/json")
            .body(Full::new(Bytes::from(bytes)).boxed())
            .unwrap()
    }
}

// ä½¿ç”¨è‡ªå®šä¹‰å“åº”
#[get("/api/users/{id}")]
async fn get_user(#[path] id: u32) -> ApiResponse<User> {
    ApiResponse {
        code: 0,
        message: "Success".into(),
        data: Some(user),
    }
}
```

## ç©ºå“åº”

### è¿”å›çŠ¶æ€ç ï¼ˆæ— å†…å®¹ï¼‰

ç›´æ¥è¿”å› `StatusCode` ä¼šç”Ÿæˆç©ºå“åº”ä½“ï¼š

```rust
// 204 No Content
#[delete("/users/{id}")]
async fn delete_user(#[path] id: u32) -> StatusCode {
    // æ‰§è¡Œåˆ é™¤æ“ä½œ
    StatusCode::NO_CONTENT
}

// 202 Accepted
#[post("/tasks")]
async fn create_task(Json(data): Json<Task>) -> StatusCode {
    // æäº¤å¼‚æ­¥ä»»åŠ¡
    StatusCode::ACCEPTED
}
```

### è¿”å›å•å…ƒç±»å‹

```rust
// è¿”å›å•å…ƒç±»å‹ - é»˜è®¤ 200 OK
#[post("/notify")]
async fn notify() -> () {
    // å‘é€é€šçŸ¥
}
```

## å“åº”æ„å»ºå™¨

ä½¿ç”¨ Hyper çš„å“åº”æ„å»ºå™¨ï¼š

```rust
use hyper::Response;
use bytes::Bytes;
use http_body_util::Full;

#[get("/custom")]
async fn custom_response() -> Response<BoxBody<Bytes, Infallible>> {
    Response::builder()
        .status(StatusCode::OK)
        .header("X-Custom", "value")
        .header("Content-Type", "text/plain")
        .body(Full::new(Bytes::from("Custom response")).boxed())
        .unwrap()
}
```

## æ¡ä»¶å“åº”

æ ¹æ®æ¡ä»¶è¿”å›ä¸åŒå“åº”ï¼š

```rust
#[get("/users/{id}")]
async fn get_user_conditional(
    #[path] id: u32,
    headers: HeaderMap,
) -> impl IntoResponse {
    let user = db.find_user(id);

    match user {
        Some(u) if headers.contains_key("X-Include-Details") => {
            // è¿”å›è¯¦ç»†ä¿¡æ¯
            Json(UserDetail::from(u)).into_response()
        }
        Some(u) => {
            // è¿”å›åŸºæœ¬ä¿¡æ¯
            Json(UserBasic::from(u)).into_response()
        }
        None => {
            // è¿”å› 404
            StatusCode::NOT_FOUND.into_response()
        }
    }
}
```

## å®Œæ•´ç¤ºä¾‹

```rust
use miko::{*, extractor::{Json, Path},
use miko::macros::*;
http::response::into_response::Html};
use serde::{Deserialize, Serialize};
use hyper::{StatusCode, HeaderMap};

#[derive(Serialize, Deserialize)]
struct Post {
    id: u32,
    title: String,
    content: String,
}

#[derive(Deserialize)]
struct CreatePost {
    title: String,
    content: String,
}

// æ–‡æœ¬å“åº”
#[get("/")]
async fn index() -> &'static str {
    "Welcome to Blog API"
}

// HTML å“åº”
#[get("/page")]
async fn page() -> Html {
    Html("<h1>My Blog</h1>".into())
}

// JSON å“åº”
#[get("/posts")]
async fn list_posts() -> Json<Vec<Post>> {
    Json(vec![
        Post { id: 1, title: "First".into(), content: "...".into() }
    ])
}

// å¸¦çŠ¶æ€ç çš„ JSON
#[post("/posts")]
async fn create_post(
    Json(data): Json<CreatePost>
) -> (StatusCode, Json<Post>) {
    let post = Post {
        id: 1,
        title: data.title,
        content: data.content,
    };
    (StatusCode::CREATED, Json(post))
}

// Result ç±»å‹
#[get("/posts/{id}")]
async fn get_post(#[path] id: u32) -> AppResult<Json<Post>> {
    let post = db.find_post(id)
        .ok_or(AppError::NotFound("Post not found".into()))?;
    Ok(Json(post))
}

// å¸¦å“åº”å¤´
#[put("/posts/{id}")]
async fn update_post(
    #[path] id: u32,
    Json(data): Json<CreatePost>,
) -> AppResult<(HeaderMap, Json<Post>)> {
    let post = db.update_post(id, data)?;

    let mut headers = HeaderMap::new();
    headers.insert("X-Updated-At", chrono::Utc::now().to_string().parse().unwrap());

    Ok((headers, Json(post)))
}

// åˆ é™¤ - æ— å†…å®¹
#[delete("/posts/{id}")]
async fn delete_post(#[path] id: u32) -> AppResult<StatusCode> {
    db.delete_post(id)?;
    Ok(StatusCode::NO_CONTENT)
}

// SSE ç¤ºä¾‹
#[get("/events")]
async fn events() {
    |sender: SseSender| async move {
        for i in 1..=5 {
            tokio::time::sleep(Duration::from_secs(1)).await;
            sender.send(format!("Event {}", i)).await.or_break();
        }
    }
}

#[miko(sse)]  // å¯ç”¨ SSE æ”¯æŒ
async fn main() {
    println!("ğŸš€ Blog API running");
}
```

## ä¸‹ä¸€æ­¥

- âš ï¸ å­¦ä¹  [é”™è¯¯å¤„ç†](é”™è¯¯å¤„ç†.md) æœºåˆ¶
- ğŸ” äº†è§£ [è¯·æ±‚æå–å™¨](è¯·æ±‚æå–å™¨.md) çš„ç”¨æ³•
- ğŸŒ æ¢ç´¢ [WebSocket](WebSocketæ”¯æŒ.md) åŒå‘é€šä¿¡
