# 请求提取器

提取器（Extractor）用于从 HTTP 请求中提取数据，是 Miko 框架中处理请求参数的核心机制。

## 提取器类型

Miko 提供两种类型的提取器：

### FromRequestParts

从请求的部分信息中提取，**不消费请求体**。可以在一个 Handler 中使用多个：

- `Path<T>` - 路径参数
- `Query<T>` - 查询参数
- `State<T>` - 全局状态
- `HeaderMap` - 请求头
- `Method` - HTTP 方法
- `Uri` - 请求 URI

### FromRequest

从完整请求中提取，**可能消费请求体**。一个 Handler 只能有一个：

- `Json<T>` - JSON 请求体
- `Form<T>` - 表单数据
- `Multipart` `MultipartResult` - 文件上传
- `ValidatedJson<T>` - 验证的 JSON（需要 `validation` feature，使用`garde`）

## Json - JSON 请求体

从请求体中反序列化 JSON 数据：

```rust
use miko::{*, extractor::Json};
use serde::{Deserialize, Serialize};

#[derive(Deserialize)]
struct CreateUser {
    name: String,
    email: String,
    age: u8,
}

#[derive(Serialize)]
struct User {
    id: u32,
    name: String,
    email: String,
}

#[post("/users")]
async fn create_user(Json(data): Json<CreateUser>) -> Json<User> {
    Json(User {
        id: 1,
        name: data.name,
        email: data.email,
    })
}
```

**自动错误处理**：如果 JSON 解析失败，会自动返回 400 Bad Request。

## Query - 查询参数

从 URL 查询字符串中提取参数：

### 基础用法

```rust
use miko::{*, extractor::Query};
use serde::Deserialize;

// 使用结构体
#[derive(Deserialize)]
struct Pagination {
    page: Option<u32>,
    per_page: Option<u32>,
}

#[get("/users")]
async fn list_users(Query(pagination): Query<Pagination>) -> String {
    let page = pagination.page.unwrap_or(1);
    let per_page = pagination.per_page.unwrap_or(20);
    format!("Page: {}, Per page: {}", page, per_page)
}
```

访问示例：
- `/users?page=2&per_page=50`

### 获取原始查询字符串

如果需要访问整个查询字符串而不解析为特定类型，可以使用 `RawQuery`：

```rust
use miko::*;
use hyper::Uri;

#[get("/search")]
async fn search(uri: Uri) -> String {
    let query = uri.query().unwrap_or("");
    format!("Raw query: {}", query)
}
```

或者创建自定义提取器获取解析后的 HashMap：

```rust
use std::collections::HashMap;
use miko::extractor::from_request::FromRequestParts;
use hyper::http::request::Parts;
use std::sync::Arc;

/// 原始查询参数 Map
pub struct QueryMap(pub HashMap<String, String>);

impl<S> FromRequestParts<S> for QueryMap {
    fn from_request_parts(
        req: &mut Parts,
        _state: Arc<S>
    ) -> miko::extractor::from_request::FRPFut<Self> {
        let query = req.uri.query().unwrap_or("");
        Box::pin(async move {
            let mut map = HashMap::new();
            for (key, value) in url::form_urlencoded::parse(query.as_bytes()) {
                map.insert(key.into_owned(), value.into_owned());
            }
            Ok(QueryMap(map))
        })
    }
}

// 使用
#[get("/search")]
async fn search(QueryMap(params): QueryMap) -> String {
    format!("Params: {:?}", params)
}
```

> **注意**: `Query<T>` 不支持 `HashMap<String, String>` 类型，因为这会与 `Deserialize` trait 产生冲突。请使用上述自定义 `QueryMap` 提取器。

## Path - 路径参数

从 URL 路径中提取参数（按序提取，没能力判断变量名）：

### 单个参数

```rust
use miko::{*, extractor::Path};

#[get("/users/{id}")]
async fn get_user(Path(id): Path<u32>) -> String {
    format!("User ID: {}", id)
}
```

### 多个参数

```rust
#[get("/users/{user_id}/posts/{post_id}")]
async fn get_post(
    Path((user_id, post_id)): Path<(u32, u32)>
) -> String {
    format!("User: {}, Post: {}", user_id, post_id)
}
```

### 使用 `#[path]` 注解（使用宏的情况下可用）

```rust
#[get("/users/{id}")]
async fn get_user(#[path] id: u32) -> String {
    format!("User ID: {}", id)
}

#[get("/users/{user_id}/posts/{post_id}")]
async fn get_post(
    #[path] user_id: u32,
    #[path] post_id: u32,
) -> String {
    format!("User: {}, Post: {}", user_id, post_id)
}
```

**类型安全**：Path 支持任何实现 `FromStr` 的类型，转换失败会返回 400 错误。

## Form - 表单数据

提取 `application/x-www-form-urlencoded` 格式的表单数据：

```rust
use miko::{*, extractor::Form};
use serde::Deserialize;

#[derive(Deserialize)]
struct LoginForm {
    username: String,
    password: String,
}

#[post("/login")]
async fn login(Form(form): Form<LoginForm>) -> String {
    format!("Login: {}", form.username)
}
```

HTML 表单示例：

```html
<form method="POST" action="/login">
    <input name="username" type="text">
    <input name="password" type="password">
    <button type="submit">Login</button>
</form>
```

## State - 全局状态

提取通过 `Router::with_state` 设置的全局状态（记得提前设置，在route时挂载到单个路由函数）：

```rust
use miko::{*, extractor::State};
use std::sync::Arc;

struct AppState {
    db: Database,
    cache: Cache,
}

#[get("/users")]
async fn list_users(State(state): State<AppState>) -> String {
    // 使用 state.db, state.cache
    format!("Users from DB: {}", state.db.count())
}

#[tokio::main]
async fn main() {
    let state = AppState {
        db: Database::new(),
        cache: Cache::new(),
    };

    let router = Router::new()
        .with_state(state)
        .get("/users", list_users);

    let config = ApplicationConfig::default();
    Application::new(config, router).run().await.unwrap();
}
```

State 会被包装为 `Arc<T>`，可以安全地在多个 handler 间共享。

> **⚠️ 重要提示**: `#[dep]` 和 `State` 基本上不能混用。
>
> - 使用 `#[miko]` 宏时会自动注册路由，此时所有路由的 State 类型都是 `()`
> - 如果需要同时使用依赖注入和自定义 State，需要：
>   1. 开启 `auto` feature
>   2. **不使用** `#[miko]` 宏
>   3. 手动注册路由并设置 State
>
> 示例：
> ```rust
> // ❌ 不能混用 - #[miko] 宏会导致 State 为 ()
> #[miko]
> async fn main() {
>     // 路由自动注册，State 类型是 ()
> }
>
> // ✅ 可以混用 - 手动注册路由
> #[tokio::main]
> async fn main() {
>     use miko::auto::init_container;
>
>     // 初始化依赖容器（支持 #[dep]）
>     init_container().await;
>
>     let state = AppState { /* ... */ };
>     let router = Router::new()
>         .with_state(state)
>         .get("/users", list_users);  // 可以使用 #[dep] 和 State
>
>     Application::new_(router).run().await.unwrap();
> }
> ```
>
> **推荐**: 优先使用 `#[dep]` 依赖注入，避免混用 State。

## 请求头

提取 HTTP 请求头：

```rust
use hyper::HeaderMap;

#[get("/headers")]
async fn check_headers(headers: HeaderMap) -> String {
    let auth = headers
        .get("authorization")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("none");

    format!("Authorization: {}", auth)
}
```

## 使用 `#[dep]` 注入依赖

> **需要 `auto` feature**

使用依赖注入代替 State：

```rust
use miko::*;
use std::sync::Arc;

#[component]
impl Database {
    async fn new() -> Self {
        Self { /* 初始化 */ }
    }

    pub fn get_user(&self, id: u32) -> User {
        // ...
    }
}

#[get("/users/{id}")]
async fn get_user(
    #[path] id: u32,
    #[dep] db: Arc<Database>,
) -> Json<User> {
    Json(db.get_user(id))
}
```

详见 [依赖注入](依赖注入.md)。

## 使用 `#[config]` 注入配置

从配置文件中注入值：

```rust
#[get("/info")]
async fn info(
    #[config("app.name")] app_name: String,
    #[config("app.version")] version: String,
) -> String {
    format!("{} v{}", app_name, version)
}
```

配置文件 `config.toml`：

```toml
[app]
name = "My App"
version = "1.0.0"
```

详见 [配置管理](配置管理.md)。

## Multipart / MultipartResult - 文件上传

处理 `multipart/form-data` 请求，用于文件上传。Miko 提供两种方式：

### MultipartResult - 自动解析（推荐）

自动解析所有字段和文件，文件会被保存到临时文件：

```rust
use miko::{*, extractor::multipart::MultipartResult};

#[post("/upload")]
async fn upload(multipart: MultipartResult) -> AppResult<String> {
    // 访问普通表单字段
    if let Some(titles) = multipart.fields.get("title") {
        println!("Title: {}", titles.first().unwrap());
    }

    // 访问上传的文件
    if let Some(files) = multipart.files.get("file") {
        for file in files {
            println!("Uploaded: {} ({} bytes)", file.filename, file.size);
            println!("Content-Type: {:?}", file.content_type);

            // 复制到目标位置
            file.linker.transfer_to(format!("uploads/{}", file.filename)).await?;
        }
    }

    Ok(format!("Uploaded {} files", multipart.files.len()))
}
```

**MultipartResult 结构**：

```rust
pub struct MultipartResult {
    pub fields: HashMap<String, Vec<String>>,  // 普通字段
    pub files: HashMap<String, Vec<MultipartFile>>,  // 文件字段
}

pub struct MultipartFile {
    pub filename: String,           // 原始文件名
    pub size: usize,                // 文件大小（字节）
    pub content_type: Option<Mime>, // MIME 类型
    pub linker: MultipartFileDiskLinker,  // 磁盘链接器
}
```

**MultipartFileDiskLinker 方法**：

```rust
// 复制到指定路径
pub async fn transfer_to(&self, path: impl Into<PathBuf>) -> Result<u64, std::io::Error>

// 读取整个文件为字符串
pub async fn read_to_string(&mut self) -> Result<String, std::io::Error>

// 读取所有字节并关闭文件
pub async fn read_and_drop_file(mut self) -> Result<Bytes, std::io::Error>

// 获取文件元数据
pub async fn metadata(&self) -> std::io::Result<Metadata>
```

### 完整示例

```rust
use miko::{*, extractor::multipart::MultipartResult};

#[post("/upload")]
async fn upload_files(multipart: MultipartResult) -> AppResult<Json<serde_json::Value>> {
    let mut uploaded = vec![];

    // 处理每个文件
    for (field_name, files) in &multipart.files {
        for file in files {
            // 生成安全的文件名
            let safe_name = format!("{}_{}",
                chrono::Utc::now().timestamp(),
                file.filename
            );

            // 保存到 uploads 目录
            let dest = format!("uploads/{}", safe_name);
            file.linker.transfer_to(&dest).await?;

            uploaded.push(serde_json::json!({
                "field": field_name,
                "original_name": file.filename,
                "saved_as": safe_name,
                "size": file.size,
                "content_type": file.content_type.as_ref().map(|m| m.to_string()),
            }));
        }
    }

    Ok(Json(serde_json::json!({
        "message": "Upload successful",
        "files": uploaded,
    })))
}
```

### Multipart - 手动解析

对于需要流式处理或自定义解析逻辑的场景，使用原始 `Multipart`：

```rust
use miko::{*, extractor::multipart::Multipart};

#[post("/upload-stream")]
async fn upload_stream(mut multipart: Multipart) -> AppResult<String> {
    let mut count = 0;

    while let Some(field) = multipart.0.next_field().await? {
        let name = field.name().unwrap_or("unknown");

        if let Some(filename) = field.file_name() {
            let data = field.bytes().await?;
            println!("File: {}, Size: {}", filename, data.len());

            // 自定义保存逻辑
            tokio::fs::write(format!("uploads/{}", filename), data).await?;
            count += 1;
        } else {
            // 普通字段
            let value = field.text().await?;
            println!("Field {}: {}", name, value);
        }
    }

    Ok(format!("Uploaded {} files", count))
}
```

### 前端示例

HTML 表单：

```html
<form method="POST" action="/upload" enctype="multipart/form-data">
    <input name="title" type="text" placeholder="标题">
    <input name="file" type="file" multiple>
    <button type="submit">上传</button>
</form>
```

JavaScript Fetch API：

```javascript
const formData = new FormData();
formData.append('title', 'My Upload');
formData.append('file', fileInput.files[0]);

fetch('/upload', {
    method: 'POST',
    body: formData
});
```

### 多文件上传示例

```rust
#[post("/upload-multiple")]
async fn upload_multiple(multipart: MultipartResult) -> AppResult<String> {
    let mut total_size = 0;
    let mut file_count = 0;

    // 遍历所有文件字段
    for (field_name, files) in &multipart.files {
        println!("Processing field: {}", field_name);

        for (index, file) in files.iter().enumerate() {
            total_size += file.size;
            file_count += 1;

            // 为每个文件生成唯一名称
            let dest = format!("uploads/{}_{}.{}",
                field_name,
                index,
                file.filename.split('.').last().unwrap_or("bin")
            );

            file.linker.transfer_to(dest).await?;
        }
    }

    Ok(format!(
        "Uploaded {} files, total size: {} bytes",
        file_count,
        total_size
    ))
}
```

### 读取文件内容

```rust
#[post("/process-csv")]
async fn process_csv(mut multipart: MultipartResult) -> AppResult<Json<Vec<String>>> {
    if let Some(files) = multipart.files.get_mut("csv") {
        if let Some(file) = files.first_mut() {
            // 读取为字符串
            let content = file.linker.read_to_string().await?;

            // 解析 CSV
            let lines: Vec<String> = content
                .lines()
                .map(|s| s.to_string())
                .collect();

            return Ok(Json(lines));
        }
    }

    Err(AppError::BadRequest("No CSV file uploaded".into()))
}
```

### 验证文件类型和大小

```rust
#[post("/upload-image")]
async fn upload_image(multipart: MultipartResult) -> AppResult<String> {
    if let Some(files) = multipart.files.get("image") {
        for file in files {
            // 验证 MIME 类型
            if let Some(mime) = &file.content_type {
                if !mime.type_().as_str().starts_with("image/") {
                    return Err(AppError::BadRequest(
                        format!("File {} is not an image", file.filename)
                    ));
                }
            }

            // 验证文件大小 (最大 5MB)
            const MAX_SIZE: usize = 5 * 1024 * 1024;
            if file.size > MAX_SIZE {
                return Err(AppError::BadRequest(
                    format!("File {} exceeds 5MB limit", file.filename)
                ));
            }

            // 保存文件
            file.linker.transfer_to(format!("images/{}", file.filename)).await?;
        }
    }

    Ok("Images uploaded successfully".to_string())
}
```

详见 [高级特性 - 文件上传](高级特性.md#文件上传)。

## ValidatedJson - 验证的 JSON

> **需要 `validation` feature**

自动验证 JSON 数据：

```rust
use miko::{*, extractor::ValidatedJson};
use serde::Deserialize;
use garde::Validate;

#[derive(Deserialize, Validate)]
struct CreateUser {
    #[garde(length(min = 3, max = 50))]
    name: String,

    #[garde(contains("@"))]
    email: String,

    #[garde(range(min = 18, max = 120))]
    age: u8,
}

#[post("/users")]
async fn create_user(
    ValidatedJson(data): ValidatedJson<CreateUser>
) -> Json<User> {
    // 数据已通过验证
    Json(User {
        id: 1,
        name: data.name,
        email: data.email,
    })
}
```

如果验证失败，会自动返回包含详细错误信息的 400 响应。

详见 [数据验证](数据验证.md)。

## 组合多个提取器

一个 Handler 可以使用多个提取器：

```rust
use miko::{*, extractor::{Json, Path, Query}};
use serde::Deserialize;

#[derive(Deserialize)]
struct UpdateData {
    name: String,
}

#[derive(Deserialize)]
struct Options {
    notify: Option<bool>,
}

#[put("/users/{id}")]
async fn update_user(
    #[path] id: u32,                          // FromRequestParts
    Query(options): Query<Options>,            // FromRequestParts
    headers: HeaderMap,                        // FromRequestParts
    Json(data): Json<UpdateData>,              // FromRequest
) -> AppResult<Json<User>> {
    // 使用所有提取的数据
    Ok(Json(user))
}
```

**重要规则**：
- 可以有多个 `FromRequestParts` 提取器
- 只能有一个 `FromRequest` 提取器（消费请求体）

## 自定义提取器

实现 `FromRequest` 或 `FromRequestParts` trait：

```rust
use miko::extractor::from_request::FromRequestParts;
use miko::handler::Req;
use hyper::http::request::Parts;
use std::sync::Arc;

struct AuthUser {
    id: u32,
    name: String,
}

impl<S> FromRequestParts<S> for AuthUser {
    fn from_request_parts(
        parts: &mut Parts,
        _state: Arc<S>
    ) -> miko::extractor::from_request::FRPFut<Self> {
        let token = parts
            .headers
            .get("authorization")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("");

        Box::pin(async move {
            if token.is_empty() {
                return Err(AppError::Unauthorized("Missing token".into()));
            }

            // 验证 token 并获取用户信息
            Ok(AuthUser {
                id: 1,
                name: "User".into(),
            })
        })
    }
}

// 使用自定义提取器
#[get("/profile")]
async fn profile(user: AuthUser) -> String {
    format!("Hello, {}!", user.name)
}
```

## 错误处理

提取器失败时会自动返回错误响应：

| 提取器 | 失败场景 | 错误码 | 错误信息 |
|--------|----------|--------|----------|
| `Json<T>` | JSON 解析失败 | 400 | JsonParseError |
| `Query<T>` | URL 解码失败 | 400 | UrlEncodedParseError |
| `Path<T>` | 类型转换失败 | 400 | BadRequest |
| `Form<T>` | 表单解析失败 | 400 | UrlEncodedParseError |
| `ValidatedJson<T>` | 验证失败 | 400 | ValidationError |

所有错误都会转换为统一的 JSON 格式。详见 [错误处理](错误处理.md)。

## 最佳实践

### 1. 使用参数注解

对于简单场景，使用 `#[path]`、`#[query]` 等注解更简洁：

```rust
// ✅ 简洁
#[get("/users/{id}")]
async fn get_user(#[path] id: u32) { }

// ✅ 也可以
#[get("/users/{id}")]
async fn get_user(Path(id): Path<u32>) { }
```

### 2. 合理使用 Option

查询参数和可选字段使用 `Option`：

```rust
#[derive(Deserialize)]
struct Filters {
    status: Option<String>,
    category: Option<String>,
    page: Option<u32>,
}
```

### 3. 组合依赖注入

结合多种提取方式：

```rust
#[get("/users/{id}")]
async fn get_user(
    #[path] id: u32,
    #[dep] db: Arc<Database>,
    #[config("feature.cache")] use_cache: bool,
    user: AuthUser,  // 自定义提取器
) -> AppResult<Json<User>> {
    // ...
}
```

### 4. 获取原始查询参数

如果需要动态查询参数而不是固定结构体，使用自定义 `QueryMap`：

```rust
// ✅ 推荐 - 使用结构体
#[derive(Deserialize)]
struct SearchQuery {
    q: String,
    page: Option<u32>,
}

#[get("/search")]
async fn search(Query(query): Query<SearchQuery>) { }

// ✅ 动态参数 - 使用自定义 QueryMap
#[get("/search")]
async fn search_dynamic(QueryMap(params): QueryMap) {
    // params 是 HashMap<String, String>
}

// ❌ 不支持 - HashMap 与 Deserialize 冲突
#[get("/search")]
async fn search(Query(params): Query<HashMap<String, String>>) { }
```

## 完整示例

```rust
use miko::{*, extractor::{Json, Path, Query}};
use serde::{Deserialize, Serialize};

#[derive(Deserialize)]
struct CreatePost {
    title: String,
    content: String,
}

#[derive(Deserialize)]
struct ListQuery {
    page: Option<u32>,
    per_page: Option<u32>,
    tag: Option<String>,
}

#[derive(Serialize)]
struct Post {
    id: u32,
    title: String,
    content: String,
}

// 列表 - 查询参数
#[get("/posts")]
async fn list_posts(Query(query): Query<ListQuery>) -> Json<Vec<Post>> {
    let page = query.page.unwrap_or(1);
    let per_page = query.per_page.unwrap_or(20);

    // 查询数据库
    Json(vec![])
}

// 获取单个 - 路径参数
#[get("/posts/{id}")]
async fn get_post(#[path] id: u32) -> AppResult<Json<Post>> {
    // 查询数据库
    Ok(Json(Post {
        id,
        title: "Example".into(),
        content: "Content".into(),
    }))
}

// 创建 - JSON 请求体
#[post("/posts")]
async fn create_post(Json(data): Json<CreatePost>) -> Json<Post> {
    Json(Post {
        id: 1,
        title: data.title,
        content: data.content,
    })
}

// 组合多个提取器
#[put("/posts/{id}")]
async fn update_post(
    #[path] id: u32,
    headers: HeaderMap,
    Query(query): Query<ListQuery>,
    Json(data): Json<CreatePost>,
) -> AppResult<Json<Post>> {
    // 检查权限
    let auth = headers.get("authorization");

    // 更新数据
    Ok(Json(Post {
        id,
        title: data.title,
        content: data.content,
    }))
}

#[miko]
async fn main() {
    println!("🚀 Server running");
}
```

## 下一步

- 📤 学习 [响应处理](响应处理.md) 的各种方式
- ⚠️ 了解 [错误处理](错误处理.md) 机制
- ✅ 使用 [数据验证](数据验证.md) 验证输入
- 💉 探索 [依赖注入](依赖注入.md) 功能
