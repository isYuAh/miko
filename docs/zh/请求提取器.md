# è¯·æ±‚æå–å™¨

æå–å™¨ï¼ˆExtractorï¼‰ç”¨äºä» HTTP è¯·æ±‚ä¸­æå–æ•°æ®ï¼Œæ˜¯ Miko æ¡†æ¶ä¸­å¤„ç†è¯·æ±‚å‚æ•°çš„æ ¸å¿ƒæœºåˆ¶ã€‚

## æå–å™¨ç±»å‹

Miko æä¾›ä¸¤ç§ç±»å‹çš„æå–å™¨ï¼š

### FromRequestParts

ä»è¯·æ±‚çš„éƒ¨åˆ†ä¿¡æ¯ä¸­æå–ï¼Œ**ä¸æ¶ˆè´¹è¯·æ±‚ä½“**ã€‚å¯ä»¥åœ¨ä¸€ä¸ª Handler ä¸­ä½¿ç”¨å¤šä¸ªï¼š

- `Path<T>` - è·¯å¾„å‚æ•°
- `Query<T>` - æŸ¥è¯¢å‚æ•°
- `State<T>` - å…¨å±€çŠ¶æ€
- `HeaderMap` - è¯·æ±‚å¤´
- `Method` - HTTP æ–¹æ³•
- `Uri` - è¯·æ±‚ URI

### FromRequest

ä»å®Œæ•´è¯·æ±‚ä¸­æå–ï¼Œ**å¯èƒ½æ¶ˆè´¹è¯·æ±‚ä½“**ã€‚ä¸€ä¸ª Handler åªèƒ½æœ‰ä¸€ä¸ªï¼š

- `Json<T>` - JSON è¯·æ±‚ä½“
- `Form<T>` - è¡¨å•æ•°æ®
- `Multipart` `MultipartResult` - æ–‡ä»¶ä¸Šä¼ 
- `ValidatedJson<T>` - éªŒè¯çš„ JSONï¼ˆéœ€è¦ `validation` featureï¼Œä½¿ç”¨`garde`ï¼‰

## Json - JSON è¯·æ±‚ä½“

ä»è¯·æ±‚ä½“ä¸­ååºåˆ—åŒ– JSON æ•°æ®ï¼š

```rust
use miko::{*, extractor::Json};
use serde::{Deserialize, Serialize};

#[derive(Deserialize)]
struct CreateUser {
    name: String,
    email: String,
    age: u8,
}

#[derive(Serialize)]
struct User {
    id: u32,
    name: String,
    email: String,
}

#[post("/users")]
async fn create_user(Json(data): Json<CreateUser>) -> Json<User> {
    Json(User {
        id: 1,
        name: data.name,
        email: data.email,
    })
}
```

**è‡ªåŠ¨é”™è¯¯å¤„ç†**ï¼šå¦‚æœ JSON è§£æå¤±è´¥ï¼Œä¼šè‡ªåŠ¨è¿”å› 400 Bad Requestã€‚

## Query - æŸ¥è¯¢å‚æ•°

ä» URL æŸ¥è¯¢å­—ç¬¦ä¸²ä¸­æå–å‚æ•°ï¼š

### åŸºç¡€ç”¨æ³•

```rust
use miko::{*, extractor::Query};
use serde::Deserialize;

// ä½¿ç”¨ç»“æ„ä½“
#[derive(Deserialize)]
struct Pagination {
    page: Option<u32>,
    per_page: Option<u32>,
}

#[get("/users")]
async fn list_users(Query(pagination): Query<Pagination>) -> String {
    let page = pagination.page.unwrap_or(1);
    let per_page = pagination.per_page.unwrap_or(20);
    format!("Page: {}, Per page: {}", page, per_page)
}
```

è®¿é—®ç¤ºä¾‹ï¼š
- `/users?page=2&per_page=50`

### è·å–åŸå§‹æŸ¥è¯¢å­—ç¬¦ä¸²

å¦‚æœéœ€è¦è®¿é—®æ•´ä¸ªæŸ¥è¯¢å­—ç¬¦ä¸²è€Œä¸è§£æä¸ºç‰¹å®šç±»å‹ï¼Œå¯ä»¥ä½¿ç”¨ `RawQuery`ï¼š

```rust
use miko::*;
use hyper::Uri;

#[get("/search")]
async fn search(uri: Uri) -> String {
    let query = uri.query().unwrap_or("");
    format!("Raw query: {}", query)
}
```

æˆ–è€…åˆ›å»ºè‡ªå®šä¹‰æå–å™¨è·å–è§£æåçš„ HashMapï¼š

```rust
use std::collections::HashMap;
use miko::extractor::from_request::FromRequestParts;
use hyper::http::request::Parts;
use std::sync::Arc;

/// åŸå§‹æŸ¥è¯¢å‚æ•° Map
pub struct QueryMap(pub HashMap<String, String>);

impl<S> FromRequestParts<S> for QueryMap {
    fn from_request_parts(
        req: &mut Parts,
        _state: Arc<S>
    ) -> miko::extractor::from_request::FRPFut<Self> {
        let query = req.uri.query().unwrap_or("");
        Box::pin(async move {
            let mut map = HashMap::new();
            for (key, value) in url::form_urlencoded::parse(query.as_bytes()) {
                map.insert(key.into_owned(), value.into_owned());
            }
            Ok(QueryMap(map))
        })
    }
}

// ä½¿ç”¨
#[get("/search")]
async fn search(QueryMap(params): QueryMap) -> String {
    format!("Params: {:?}", params)
}
```

> **æ³¨æ„**: `Query<T>` ä¸æ”¯æŒ `HashMap<String, String>` ç±»å‹ï¼Œå› ä¸ºè¿™ä¼šä¸ `Deserialize` trait äº§ç”Ÿå†²çªã€‚è¯·ä½¿ç”¨ä¸Šè¿°è‡ªå®šä¹‰ `QueryMap` æå–å™¨ã€‚

## Path - è·¯å¾„å‚æ•°

ä» URL è·¯å¾„ä¸­æå–å‚æ•°ï¼ˆæŒ‰åºæå–ï¼Œæ²¡èƒ½åŠ›åˆ¤æ–­å˜é‡åï¼‰ï¼š

### å•ä¸ªå‚æ•°

```rust
use miko::{*, extractor::Path};

#[get("/users/{id}")]
async fn get_user(Path(id): Path<u32>) -> String {
    format!("User ID: {}", id)
}
```

### å¤šä¸ªå‚æ•°

```rust
#[get("/users/{user_id}/posts/{post_id}")]
async fn get_post(
    Path((user_id, post_id)): Path<(u32, u32)>
) -> String {
    format!("User: {}, Post: {}", user_id, post_id)
}
```

### ä½¿ç”¨ `#[path]` æ³¨è§£ï¼ˆä½¿ç”¨å®çš„æƒ…å†µä¸‹å¯ç”¨ï¼‰

```rust
#[get("/users/{id}")]
async fn get_user(#[path] id: u32) -> String {
    format!("User ID: {}", id)
}

#[get("/users/{user_id}/posts/{post_id}")]
async fn get_post(
    #[path] user_id: u32,
    #[path] post_id: u32,
) -> String {
    format!("User: {}, Post: {}", user_id, post_id)
}
```

**ç±»å‹å®‰å…¨**ï¼šPath æ”¯æŒä»»ä½•å®ç° `FromStr` çš„ç±»å‹ï¼Œè½¬æ¢å¤±è´¥ä¼šè¿”å› 400 é”™è¯¯ã€‚

## Form - è¡¨å•æ•°æ®

æå– `application/x-www-form-urlencoded` æ ¼å¼çš„è¡¨å•æ•°æ®ï¼š

```rust
use miko::{*, extractor::Form};
use serde::Deserialize;

#[derive(Deserialize)]
struct LoginForm {
    username: String,
    password: String,
}

#[post("/login")]
async fn login(Form(form): Form<LoginForm>) -> String {
    format!("Login: {}", form.username)
}
```

HTML è¡¨å•ç¤ºä¾‹ï¼š

```html
<form method="POST" action="/login">
    <input name="username" type="text">
    <input name="password" type="password">
    <button type="submit">Login</button>
</form>
```

## State - å…¨å±€çŠ¶æ€

æå–é€šè¿‡ `Router::with_state` è®¾ç½®çš„å…¨å±€çŠ¶æ€ï¼ˆè®°å¾—æå‰è®¾ç½®ï¼Œåœ¨routeæ—¶æŒ‚è½½åˆ°å•ä¸ªè·¯ç”±å‡½æ•°ï¼‰ï¼š

```rust
use miko::{*, extractor::State};
use std::sync::Arc;

struct AppState {
    db: Database,
    cache: Cache,
}

#[get("/users")]
async fn list_users(State(state): State<AppState>) -> String {
    // ä½¿ç”¨ state.db, state.cache
    format!("Users from DB: {}", state.db.count())
}

#[tokio::main]
async fn main() {
    let state = AppState {
        db: Database::new(),
        cache: Cache::new(),
    };

    let router = Router::new()
        .with_state(state)
        .get("/users", list_users);

    let config = ApplicationConfig::default();
    Application::new(config, router).run().await.unwrap();
}
```

State ä¼šè¢«åŒ…è£…ä¸º `Arc<T>`ï¼Œå¯ä»¥å®‰å…¨åœ°åœ¨å¤šä¸ª handler é—´å…±äº«ã€‚

> **âš ï¸ é‡è¦æç¤º**: `#[dep]` å’Œ `State` åŸºæœ¬ä¸Šä¸èƒ½æ··ç”¨ã€‚
>
> - ä½¿ç”¨ `#[miko]` å®æ—¶ä¼šè‡ªåŠ¨æ³¨å†Œè·¯ç”±ï¼Œæ­¤æ—¶æ‰€æœ‰è·¯ç”±çš„ State ç±»å‹éƒ½æ˜¯ `()`
> - å¦‚æœéœ€è¦åŒæ—¶ä½¿ç”¨ä¾èµ–æ³¨å…¥å’Œè‡ªå®šä¹‰ Stateï¼Œéœ€è¦ï¼š
>   1. å¼€å¯ `auto` feature
>   2. **ä¸ä½¿ç”¨** `#[miko]` å®
>   3. æ‰‹åŠ¨æ³¨å†Œè·¯ç”±å¹¶è®¾ç½® State
>
> ç¤ºä¾‹ï¼š
> ```rust
> // âŒ ä¸èƒ½æ··ç”¨ - #[miko] å®ä¼šå¯¼è‡´ State ä¸º ()
> #[miko]
> async fn main() {
>     // è·¯ç”±è‡ªåŠ¨æ³¨å†Œï¼ŒState ç±»å‹æ˜¯ ()
> }
>
> // âœ… å¯ä»¥æ··ç”¨ - æ‰‹åŠ¨æ³¨å†Œè·¯ç”±
> #[tokio::main]
> async fn main() {
>     use miko::auto::init_container;
>
>     // åˆå§‹åŒ–ä¾èµ–å®¹å™¨ï¼ˆæ”¯æŒ #[dep]ï¼‰
>     init_container().await;
>
>     let state = AppState { /* ... */ };
>     let router = Router::new()
>         .with_state(state)
>         .get("/users", list_users);  // å¯ä»¥ä½¿ç”¨ #[dep] å’Œ State
>
>     Application::new_(router).run().await.unwrap();
> }
> ```
>
> **æ¨è**: ä¼˜å…ˆä½¿ç”¨ `#[dep]` ä¾èµ–æ³¨å…¥ï¼Œé¿å…æ··ç”¨ Stateã€‚

## è¯·æ±‚å¤´

æå– HTTP è¯·æ±‚å¤´ï¼š

```rust
use hyper::HeaderMap;

#[get("/headers")]
async fn check_headers(headers: HeaderMap) -> String {
    let auth = headers
        .get("authorization")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("none");

    format!("Authorization: {}", auth)
}
```

## ä½¿ç”¨ `#[dep]` æ³¨å…¥ä¾èµ–

> **éœ€è¦ `auto` feature**

ä½¿ç”¨ä¾èµ–æ³¨å…¥ä»£æ›¿ Stateï¼š

```rust
use miko::*;
use std::sync::Arc;

#[component]
impl Database {
    async fn new() -> Self {
        Self { /* åˆå§‹åŒ– */ }
    }

    pub fn get_user(&self, id: u32) -> User {
        // ...
    }
}

#[get("/users/{id}")]
async fn get_user(
    #[path] id: u32,
    #[dep] db: Arc<Database>,
) -> Json<User> {
    Json(db.get_user(id))
}
```

è¯¦è§ [ä¾èµ–æ³¨å…¥](ä¾èµ–æ³¨å…¥.md)ã€‚

## ä½¿ç”¨ `#[config]` æ³¨å…¥é…ç½®

ä»é…ç½®æ–‡ä»¶ä¸­æ³¨å…¥å€¼ï¼š

```rust
#[get("/info")]
async fn info(
    #[config("app.name")] app_name: String,
    #[config("app.version")] version: String,
) -> String {
    format!("{} v{}", app_name, version)
}
```

é…ç½®æ–‡ä»¶ `config.toml`ï¼š

```toml
[app]
name = "My App"
version = "1.0.0"
```

è¯¦è§ [é…ç½®ç®¡ç†](é…ç½®ç®¡ç†.md)ã€‚

## Multipart / MultipartResult - æ–‡ä»¶ä¸Šä¼ 

å¤„ç† `multipart/form-data` è¯·æ±‚ï¼Œç”¨äºæ–‡ä»¶ä¸Šä¼ ã€‚Miko æä¾›ä¸¤ç§æ–¹å¼ï¼š

### MultipartResult - è‡ªåŠ¨è§£æï¼ˆæ¨èï¼‰

è‡ªåŠ¨è§£ææ‰€æœ‰å­—æ®µå’Œæ–‡ä»¶ï¼Œæ–‡ä»¶ä¼šè¢«ä¿å­˜åˆ°ä¸´æ—¶æ–‡ä»¶ï¼š

```rust
use miko::{*, extractor::multipart::MultipartResult};

#[post("/upload")]
async fn upload(multipart: MultipartResult) -> AppResult<String> {
    // è®¿é—®æ™®é€šè¡¨å•å­—æ®µ
    if let Some(titles) = multipart.fields.get("title") {
        println!("Title: {}", titles.first().unwrap());
    }

    // è®¿é—®ä¸Šä¼ çš„æ–‡ä»¶
    if let Some(files) = multipart.files.get("file") {
        for file in files {
            println!("Uploaded: {} ({} bytes)", file.filename, file.size);
            println!("Content-Type: {:?}", file.content_type);

            // å¤åˆ¶åˆ°ç›®æ ‡ä½ç½®
            file.linker.transfer_to(format!("uploads/{}", file.filename)).await?;
        }
    }

    Ok(format!("Uploaded {} files", multipart.files.len()))
}
```

**MultipartResult ç»“æ„**ï¼š

```rust
pub struct MultipartResult {
    pub fields: HashMap<String, Vec<String>>,  // æ™®é€šå­—æ®µ
    pub files: HashMap<String, Vec<MultipartFile>>,  // æ–‡ä»¶å­—æ®µ
}

pub struct MultipartFile {
    pub filename: String,           // åŸå§‹æ–‡ä»¶å
    pub size: usize,                // æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
    pub content_type: Option<Mime>, // MIME ç±»å‹
    pub linker: MultipartFileDiskLinker,  // ç£ç›˜é“¾æ¥å™¨
}
```

**MultipartFileDiskLinker æ–¹æ³•**ï¼š

```rust
// å¤åˆ¶åˆ°æŒ‡å®šè·¯å¾„
pub async fn transfer_to(&self, path: impl Into<PathBuf>) -> Result<u64, std::io::Error>

// è¯»å–æ•´ä¸ªæ–‡ä»¶ä¸ºå­—ç¬¦ä¸²
pub async fn read_to_string(&mut self) -> Result<String, std::io::Error>

// è¯»å–æ‰€æœ‰å­—èŠ‚å¹¶å…³é—­æ–‡ä»¶
pub async fn read_and_drop_file(mut self) -> Result<Bytes, std::io::Error>

// è·å–æ–‡ä»¶å…ƒæ•°æ®
pub async fn metadata(&self) -> std::io::Result<Metadata>
```

### å®Œæ•´ç¤ºä¾‹

```rust
use miko::{*, extractor::multipart::MultipartResult};

#[post("/upload")]
async fn upload_files(multipart: MultipartResult) -> AppResult<Json<serde_json::Value>> {
    let mut uploaded = vec![];

    // å¤„ç†æ¯ä¸ªæ–‡ä»¶
    for (field_name, files) in &multipart.files {
        for file in files {
            // ç”Ÿæˆå®‰å…¨çš„æ–‡ä»¶å
            let safe_name = format!("{}_{}",
                chrono::Utc::now().timestamp(),
                file.filename
            );

            // ä¿å­˜åˆ° uploads ç›®å½•
            let dest = format!("uploads/{}", safe_name);
            file.linker.transfer_to(&dest).await?;

            uploaded.push(serde_json::json!({
                "field": field_name,
                "original_name": file.filename,
                "saved_as": safe_name,
                "size": file.size,
                "content_type": file.content_type.as_ref().map(|m| m.to_string()),
            }));
        }
    }

    Ok(Json(serde_json::json!({
        "message": "Upload successful",
        "files": uploaded,
    })))
}
```

### Multipart - æ‰‹åŠ¨è§£æ

å¯¹äºéœ€è¦æµå¼å¤„ç†æˆ–è‡ªå®šä¹‰è§£æé€»è¾‘çš„åœºæ™¯ï¼Œä½¿ç”¨åŸå§‹ `Multipart`ï¼š

```rust
use miko::{*, extractor::multipart::Multipart};

#[post("/upload-stream")]
async fn upload_stream(mut multipart: Multipart) -> AppResult<String> {
    let mut count = 0;

    while let Some(field) = multipart.0.next_field().await? {
        let name = field.name().unwrap_or("unknown");

        if let Some(filename) = field.file_name() {
            let data = field.bytes().await?;
            println!("File: {}, Size: {}", filename, data.len());

            // è‡ªå®šä¹‰ä¿å­˜é€»è¾‘
            tokio::fs::write(format!("uploads/{}", filename), data).await?;
            count += 1;
        } else {
            // æ™®é€šå­—æ®µ
            let value = field.text().await?;
            println!("Field {}: {}", name, value);
        }
    }

    Ok(format!("Uploaded {} files", count))
}
```

### å‰ç«¯ç¤ºä¾‹

HTML è¡¨å•ï¼š

```html
<form method="POST" action="/upload" enctype="multipart/form-data">
    <input name="title" type="text" placeholder="æ ‡é¢˜">
    <input name="file" type="file" multiple>
    <button type="submit">ä¸Šä¼ </button>
</form>
```

JavaScript Fetch APIï¼š

```javascript
const formData = new FormData();
formData.append('title', 'My Upload');
formData.append('file', fileInput.files[0]);

fetch('/upload', {
    method: 'POST',
    body: formData
});
```

### å¤šæ–‡ä»¶ä¸Šä¼ ç¤ºä¾‹

```rust
#[post("/upload-multiple")]
async fn upload_multiple(multipart: MultipartResult) -> AppResult<String> {
    let mut total_size = 0;
    let mut file_count = 0;

    // éå†æ‰€æœ‰æ–‡ä»¶å­—æ®µ
    for (field_name, files) in &multipart.files {
        println!("Processing field: {}", field_name);

        for (index, file) in files.iter().enumerate() {
            total_size += file.size;
            file_count += 1;

            // ä¸ºæ¯ä¸ªæ–‡ä»¶ç”Ÿæˆå”¯ä¸€åç§°
            let dest = format!("uploads/{}_{}.{}",
                field_name,
                index,
                file.filename.split('.').last().unwrap_or("bin")
            );

            file.linker.transfer_to(dest).await?;
        }
    }

    Ok(format!(
        "Uploaded {} files, total size: {} bytes",
        file_count,
        total_size
    ))
}
```

### è¯»å–æ–‡ä»¶å†…å®¹

```rust
#[post("/process-csv")]
async fn process_csv(mut multipart: MultipartResult) -> AppResult<Json<Vec<String>>> {
    if let Some(files) = multipart.files.get_mut("csv") {
        if let Some(file) = files.first_mut() {
            // è¯»å–ä¸ºå­—ç¬¦ä¸²
            let content = file.linker.read_to_string().await?;

            // è§£æ CSV
            let lines: Vec<String> = content
                .lines()
                .map(|s| s.to_string())
                .collect();

            return Ok(Json(lines));
        }
    }

    Err(AppError::BadRequest("No CSV file uploaded".into()))
}
```

### éªŒè¯æ–‡ä»¶ç±»å‹å’Œå¤§å°

```rust
#[post("/upload-image")]
async fn upload_image(multipart: MultipartResult) -> AppResult<String> {
    if let Some(files) = multipart.files.get("image") {
        for file in files {
            // éªŒè¯ MIME ç±»å‹
            if let Some(mime) = &file.content_type {
                if !mime.type_().as_str().starts_with("image/") {
                    return Err(AppError::BadRequest(
                        format!("File {} is not an image", file.filename)
                    ));
                }
            }

            // éªŒè¯æ–‡ä»¶å¤§å° (æœ€å¤§ 5MB)
            const MAX_SIZE: usize = 5 * 1024 * 1024;
            if file.size > MAX_SIZE {
                return Err(AppError::BadRequest(
                    format!("File {} exceeds 5MB limit", file.filename)
                ));
            }

            // ä¿å­˜æ–‡ä»¶
            file.linker.transfer_to(format!("images/{}", file.filename)).await?;
        }
    }

    Ok("Images uploaded successfully".to_string())
}
```

è¯¦è§ [é«˜çº§ç‰¹æ€§ - æ–‡ä»¶ä¸Šä¼ ](é«˜çº§ç‰¹æ€§.md#æ–‡ä»¶ä¸Šä¼ )ã€‚

## ValidatedJson - éªŒè¯çš„ JSON

> **éœ€è¦ `validation` feature**

è‡ªåŠ¨éªŒè¯ JSON æ•°æ®ï¼š

```rust
use miko::{*, extractor::ValidatedJson};
use serde::Deserialize;
use garde::Validate;

#[derive(Deserialize, Validate)]
struct CreateUser {
    #[garde(length(min = 3, max = 50))]
    name: String,

    #[garde(contains("@"))]
    email: String,

    #[garde(range(min = 18, max = 120))]
    age: u8,
}

#[post("/users")]
async fn create_user(
    ValidatedJson(data): ValidatedJson<CreateUser>
) -> Json<User> {
    // æ•°æ®å·²é€šè¿‡éªŒè¯
    Json(User {
        id: 1,
        name: data.name,
        email: data.email,
    })
}
```

å¦‚æœéªŒè¯å¤±è´¥ï¼Œä¼šè‡ªåŠ¨è¿”å›åŒ…å«è¯¦ç»†é”™è¯¯ä¿¡æ¯çš„ 400 å“åº”ã€‚

è¯¦è§ [æ•°æ®éªŒè¯](æ•°æ®éªŒè¯.md)ã€‚

## ç»„åˆå¤šä¸ªæå–å™¨

ä¸€ä¸ª Handler å¯ä»¥ä½¿ç”¨å¤šä¸ªæå–å™¨ï¼š

```rust
use miko::{*, extractor::{Json, Path, Query}};
use serde::Deserialize;

#[derive(Deserialize)]
struct UpdateData {
    name: String,
}

#[derive(Deserialize)]
struct Options {
    notify: Option<bool>,
}

#[put("/users/{id}")]
async fn update_user(
    #[path] id: u32,                          // FromRequestParts
    Query(options): Query<Options>,            // FromRequestParts
    headers: HeaderMap,                        // FromRequestParts
    Json(data): Json<UpdateData>,              // FromRequest
) -> AppResult<Json<User>> {
    // ä½¿ç”¨æ‰€æœ‰æå–çš„æ•°æ®
    Ok(Json(user))
}
```

**é‡è¦è§„åˆ™**ï¼š
- å¯ä»¥æœ‰å¤šä¸ª `FromRequestParts` æå–å™¨
- åªèƒ½æœ‰ä¸€ä¸ª `FromRequest` æå–å™¨ï¼ˆæ¶ˆè´¹è¯·æ±‚ä½“ï¼‰

## è‡ªå®šä¹‰æå–å™¨

å®ç° `FromRequest` æˆ– `FromRequestParts` traitï¼š

```rust
use miko::extractor::from_request::FromRequestParts;
use miko::handler::Req;
use hyper::http::request::Parts;
use std::sync::Arc;

struct AuthUser {
    id: u32,
    name: String,
}

impl<S> FromRequestParts<S> for AuthUser {
    fn from_request_parts(
        parts: &mut Parts,
        _state: Arc<S>
    ) -> miko::extractor::from_request::FRPFut<Self> {
        let token = parts
            .headers
            .get("authorization")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("");

        Box::pin(async move {
            if token.is_empty() {
                return Err(AppError::Unauthorized("Missing token".into()));
            }

            // éªŒè¯ token å¹¶è·å–ç”¨æˆ·ä¿¡æ¯
            Ok(AuthUser {
                id: 1,
                name: "User".into(),
            })
        })
    }
}

// ä½¿ç”¨è‡ªå®šä¹‰æå–å™¨
#[get("/profile")]
async fn profile(user: AuthUser) -> String {
    format!("Hello, {}!", user.name)
}
```

## é”™è¯¯å¤„ç†

æå–å™¨å¤±è´¥æ—¶ä¼šè‡ªåŠ¨è¿”å›é”™è¯¯å“åº”ï¼š

| æå–å™¨ | å¤±è´¥åœºæ™¯ | é”™è¯¯ç  | é”™è¯¯ä¿¡æ¯ |
|--------|----------|--------|----------|
| `Json<T>` | JSON è§£æå¤±è´¥ | 400 | JsonParseError |
| `Query<T>` | URL è§£ç å¤±è´¥ | 400 | UrlEncodedParseError |
| `Path<T>` | ç±»å‹è½¬æ¢å¤±è´¥ | 400 | BadRequest |
| `Form<T>` | è¡¨å•è§£æå¤±è´¥ | 400 | UrlEncodedParseError |
| `ValidatedJson<T>` | éªŒè¯å¤±è´¥ | 400 | ValidationError |

æ‰€æœ‰é”™è¯¯éƒ½ä¼šè½¬æ¢ä¸ºç»Ÿä¸€çš„ JSON æ ¼å¼ã€‚è¯¦è§ [é”™è¯¯å¤„ç†](é”™è¯¯å¤„ç†.md)ã€‚

## æœ€ä½³å®è·µ

### 1. ä½¿ç”¨å‚æ•°æ³¨è§£

å¯¹äºç®€å•åœºæ™¯ï¼Œä½¿ç”¨ `#[path]`ã€`#[query]` ç­‰æ³¨è§£æ›´ç®€æ´ï¼š

```rust
// âœ… ç®€æ´
#[get("/users/{id}")]
async fn get_user(#[path] id: u32) { }

// âœ… ä¹Ÿå¯ä»¥
#[get("/users/{id}")]
async fn get_user(Path(id): Path<u32>) { }
```

### 2. åˆç†ä½¿ç”¨ Option

æŸ¥è¯¢å‚æ•°å’Œå¯é€‰å­—æ®µä½¿ç”¨ `Option`ï¼š

```rust
#[derive(Deserialize)]
struct Filters {
    status: Option<String>,
    category: Option<String>,
    page: Option<u32>,
}
```

### 3. ç»„åˆä¾èµ–æ³¨å…¥

ç»“åˆå¤šç§æå–æ–¹å¼ï¼š

```rust
#[get("/users/{id}")]
async fn get_user(
    #[path] id: u32,
    #[dep] db: Arc<Database>,
    #[config("feature.cache")] use_cache: bool,
    user: AuthUser,  // è‡ªå®šä¹‰æå–å™¨
) -> AppResult<Json<User>> {
    // ...
}
```

### 4. è·å–åŸå§‹æŸ¥è¯¢å‚æ•°

å¦‚æœéœ€è¦åŠ¨æ€æŸ¥è¯¢å‚æ•°è€Œä¸æ˜¯å›ºå®šç»“æ„ä½“ï¼Œä½¿ç”¨è‡ªå®šä¹‰ `QueryMap`ï¼š

```rust
// âœ… æ¨è - ä½¿ç”¨ç»“æ„ä½“
#[derive(Deserialize)]
struct SearchQuery {
    q: String,
    page: Option<u32>,
}

#[get("/search")]
async fn search(Query(query): Query<SearchQuery>) { }

// âœ… åŠ¨æ€å‚æ•° - ä½¿ç”¨è‡ªå®šä¹‰ QueryMap
#[get("/search")]
async fn search_dynamic(QueryMap(params): QueryMap) {
    // params æ˜¯ HashMap<String, String>
}

// âŒ ä¸æ”¯æŒ - HashMap ä¸ Deserialize å†²çª
#[get("/search")]
async fn search(Query(params): Query<HashMap<String, String>>) { }
```

## å®Œæ•´ç¤ºä¾‹

```rust
use miko::{*, extractor::{Json, Path, Query}};
use serde::{Deserialize, Serialize};

#[derive(Deserialize)]
struct CreatePost {
    title: String,
    content: String,
}

#[derive(Deserialize)]
struct ListQuery {
    page: Option<u32>,
    per_page: Option<u32>,
    tag: Option<String>,
}

#[derive(Serialize)]
struct Post {
    id: u32,
    title: String,
    content: String,
}

// åˆ—è¡¨ - æŸ¥è¯¢å‚æ•°
#[get("/posts")]
async fn list_posts(Query(query): Query<ListQuery>) -> Json<Vec<Post>> {
    let page = query.page.unwrap_or(1);
    let per_page = query.per_page.unwrap_or(20);

    // æŸ¥è¯¢æ•°æ®åº“
    Json(vec![])
}

// è·å–å•ä¸ª - è·¯å¾„å‚æ•°
#[get("/posts/{id}")]
async fn get_post(#[path] id: u32) -> AppResult<Json<Post>> {
    // æŸ¥è¯¢æ•°æ®åº“
    Ok(Json(Post {
        id,
        title: "Example".into(),
        content: "Content".into(),
    }))
}

// åˆ›å»º - JSON è¯·æ±‚ä½“
#[post("/posts")]
async fn create_post(Json(data): Json<CreatePost>) -> Json<Post> {
    Json(Post {
        id: 1,
        title: data.title,
        content: data.content,
    })
}

// ç»„åˆå¤šä¸ªæå–å™¨
#[put("/posts/{id}")]
async fn update_post(
    #[path] id: u32,
    headers: HeaderMap,
    Query(query): Query<ListQuery>,
    Json(data): Json<CreatePost>,
) -> AppResult<Json<Post>> {
    // æ£€æŸ¥æƒé™
    let auth = headers.get("authorization");

    // æ›´æ–°æ•°æ®
    Ok(Json(Post {
        id,
        title: data.title,
        content: data.content,
    }))
}

#[miko]
async fn main() {
    println!("ğŸš€ Server running");
}
```

## ä¸‹ä¸€æ­¥

- ğŸ“¤ å­¦ä¹  [å“åº”å¤„ç†](å“åº”å¤„ç†.md) çš„å„ç§æ–¹å¼
- âš ï¸ äº†è§£ [é”™è¯¯å¤„ç†](é”™è¯¯å¤„ç†.md) æœºåˆ¶
- âœ… ä½¿ç”¨ [æ•°æ®éªŒè¯](æ•°æ®éªŒè¯.md) éªŒè¯è¾“å…¥
- ğŸ’‰ æ¢ç´¢ [ä¾èµ–æ³¨å…¥](ä¾èµ–æ³¨å…¥.md) åŠŸèƒ½
