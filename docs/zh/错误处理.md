# é”™è¯¯å¤„ç†

Miko æä¾›äº†ç»Ÿä¸€çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œè®©ä½ å¯ä»¥ä¼˜é›…åœ°å¤„ç†å„ç§é”™è¯¯æƒ…å†µï¼Œå¹¶è¿”å›ä¸€è‡´çš„ JSON æ ¼å¼é”™è¯¯å“åº”ã€‚

## æ ¸å¿ƒç±»å‹

### AppError

æ¡†æ¶æä¾›çš„ç»Ÿä¸€é”™è¯¯ç±»å‹ï¼Œæ¶µç›–å¸¸è§çš„ HTTP é”™è¯¯åœºæ™¯ï¼š

```rust
pub enum AppError {
    // å®¢æˆ·ç«¯é”™è¯¯ (4xx)
    BadRequest(String),           // 400
    Unauthorized(String),          // 401
    Forbidden(String),             // 403
    NotFound(String),              // 404
    Conflict(String),              // 409
    UnprocessableEntity(String),   // 422
    TooManyRequests(String),       // 429

    // æœåŠ¡å™¨é”™è¯¯ (5xx)
    InternalServerError(String),   // 500
    BadGateway(String),            // 502
    ServiceUnavailable(String),    // 503
    GatewayTimeout(String),        // 504

    // å…·ä½“é”™è¯¯ç±»å‹
    JsonParseError(serde_json::Error),
    UrlEncodedParseError(serde_urlencoded::de::Error),
    ValidationError(Vec<ValidationErrorDetail>),
    DatabaseError(String),
    IoError(std::io::Error),
    Timeout(String),
    ExternalServiceError { service: String, message: String },

    // è‡ªå®šä¹‰é”™è¯¯
    Custom {
        status: StatusCode,
        error_code: String,
        message: String,
        details: Option<serde_json::Value>,
    },
}
```

### AppResult

ç±»å‹åˆ«åï¼Œç®€åŒ–é”™è¯¯å¤„ç†ï¼š

```rust
pub type AppResult<T> = Result<T, AppError>;
```

### ErrorResponse

ç»Ÿä¸€çš„é”™è¯¯å“åº”æ ¼å¼ï¼š

```rust
{
    "status": 404,
    "error": "NOT_FOUND",
    "message": "User 123 not found",
    "details": null,
    "trace_id": "req-abc-123",
    "timestamp": 1234567890
}
```

## åŸºç¡€ç”¨æ³•

### è¿”å›é”™è¯¯

åœ¨ Handler ä¸­è¿”å› `AppResult`ï¼š

```rust
use miko::{*, AppResult, AppError};

#[get("/users/{id}")]
async fn get_user(#[path] id: u32) -> AppResult<Json<User>> {
    let user = db.find_user(id)
        .ok_or(AppError::NotFound(format!("User {} not found", id)))?;

    Ok(Json(user))
}
```

### ä½¿ç”¨ ? æ“ä½œç¬¦

```rust
#[post("/users")]
async fn create_user(Json(data): Json<CreateUser>) -> AppResult<Json<User>> {
    // è‡ªåŠ¨è½¬æ¢å„ç§é”™è¯¯
    let user = db.create_user(data)?;  // io::Error -> AppError
    Ok(Json(user))
}
```

## å¸¸è§é”™è¯¯åœºæ™¯

### 404 Not Found

èµ„æºä¸å­˜åœ¨ï¼š

```rust
#[get("/users/{id}")]
async fn get_user(#[path] id: u32) -> AppResult<Json<User>> {
    let user = db.find_user(id)
        .ok_or_else(|| AppError::NotFound(format!("User {} not found", id)))?;
    Ok(Json(user))
}
```

å“åº”ç¤ºä¾‹ï¼š

```json
{
    "status": 404,
    "error": "NOT_FOUND",
    "message": "User 123 not found",
    "timestamp": 1234567890
}
```

### 400 Bad Request

è¯·æ±‚å‚æ•°é”™è¯¯ï¼š

```rust
#[post("/users")]
async fn create_user(Json(data): Json<CreateUser>) -> AppResult<Json<User>> {
    if data.email.is_empty() {
        return Err(AppError::BadRequest("Email is required".into()));
    }

    if !data.email.contains('@') {
        return Err(AppError::BadRequest("Invalid email format".into()));
    }

    Ok(Json(db.create_user(data)?))
}
```

### 401 Unauthorized

æœªè®¤è¯ï¼š

```rust
#[get("/profile")]
async fn get_profile(headers: HeaderMap) -> AppResult<Json<Profile>> {
    let token = headers
        .get("authorization")
        .and_then(|v| v.to_str().ok())
        .ok_or_else(|| AppError::Unauthorized("Missing auth token".into()))?;

    let user = verify_token(token)
        .ok_or_else(|| AppError::Unauthorized("Invalid or expired token".into()))?;

    Ok(Json(get_profile_for_user(user)))
}
```

### 403 Forbidden

å·²è®¤è¯ä½†æ— æƒé™ï¼š

```rust
#[delete("/posts/{id}")]
async fn delete_post(
    #[path] id: u32,
    user: AuthUser,  // è‡ªå®šä¹‰æå–å™¨
) -> AppResult<StatusCode> {
    let post = db.find_post(id)
        .ok_or(AppError::NotFound("Post not found".into()))?;

    if post.author_id != user.id && !user.is_admin {
        return Err(AppError::Forbidden("You don't have permission to delete this post".into()));
    }

    db.delete_post(id)?;
    Ok(StatusCode::NO_CONTENT)
}
```

### 409 Conflict

èµ„æºå†²çªï¼š

```rust
#[post("/users")]
async fn create_user(Json(data): Json<CreateUser>) -> AppResult<Json<User>> {
    if db.email_exists(&data.email) {
        return Err(AppError::Conflict("Email already exists".into()));
    }

    if db.username_exists(&data.username) {
        return Err(AppError::Conflict("Username already taken".into()));
    }

    Ok(Json(db.create_user(data)?))
}
```

### 422 Validation Error

æ•°æ®éªŒè¯å¤±è´¥ï¼š

> æ¨èä½¿ç”¨ `ValidatedJson` è‡ªåŠ¨éªŒè¯ï¼Œè¯¦è§ [æ•°æ®éªŒè¯](æ•°æ®éªŒè¯.md)

```rust
use miko::ValidationErrorDetail;

#[post("/users")]
async fn create_user(Json(data): Json<CreateUser>) -> AppResult<Json<User>> {
    let mut errors = Vec::new();

    if data.name.len() < 3 {
        errors.push(ValidationErrorDetail::invalid_length("name", 3, 50));
    }

    if !data.email.contains('@') {
        errors.push(ValidationErrorDetail::invalid_format("email", "valid email address"));
    }

    if data.age < 18 {
        errors.push(ValidationErrorDetail::min_value("age", 18));
    }

    if !errors.is_empty() {
        return Err(AppError::ValidationError(errors));
    }

    Ok(Json(db.create_user(data)?))
}
```

å“åº”ç¤ºä¾‹ï¼š

```json
{
    "status": 422,
    "error": "VALIDATION_ERROR",
    "message": "Request validation failed",
    "details": {
        "fields": [
            {
                "field": "name",
                "message": "name length must be between 3 and 50",
                "code": "VALIDATION_FAILED"
            },
            {
                "field": "email",
                "message": "email has invalid format, expected: valid email address",
                "code": "VALIDATION_FAILED"
            }
        ]
    },
    "timestamp": 1234567890
}
```

### 500 Internal Server Error

æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ï¼š

```rust
#[get("/users")]
async fn list_users() -> AppResult<Json<Vec<User>>> {
    let users = db.query_users()
        .map_err(|e| AppError::DatabaseError(format!("Failed to query users: {}", e)))?;

    Ok(Json(users))
}
```

## è‡ªåŠ¨é”™è¯¯è½¬æ¢

æ¡†æ¶ä¸ºå¸¸è§é”™è¯¯ç±»å‹å®ç°äº† `From` traitï¼š

```rust
// std::io::Error
let data = tokio::fs::read("file.txt").await?;  // è‡ªåŠ¨è½¬æ¢

// serde_json::Error
let value: MyData = serde_json::from_str(&json)?;  // è‡ªåŠ¨è½¬æ¢

// multer::Error (æ–‡ä»¶ä¸Šä¼ )
while let Some(field) = multipart.next_field().await? {  // è‡ªåŠ¨è½¬æ¢
    // ...
}
```

æ”¯æŒçš„è‡ªåŠ¨è½¬æ¢ï¼š

| é”™è¯¯ç±»å‹ | è½¬æ¢ä¸º |
|---------|--------|
| `std::io::Error` | `AppError::IoError` |
| `serde_json::Error` | `AppError::JsonParseError` |
| `serde_urlencoded::de::Error` | `AppError::UrlEncodedParseError` |
| `multer::Error` | `AppError::MultipartParseError` |
| `anyhow::Error` | `AppError::InternalServerError` |
| `garde::Report` | `AppError::ValidationError` (éœ€è¦ `validation` feature) |

## è‡ªå®šä¹‰é”™è¯¯

### ä½¿ç”¨ Custom å˜ä½“

å®Œå…¨è‡ªå®šä¹‰é”™è¯¯å“åº”ï¼š

```rust
use hyper::StatusCode;
use serde_json::json;

#[get("/custom-error")]
async fn handler() -> AppResult<()> {
    Err(AppError::custom(
        StatusCode::PAYMENT_REQUIRED,
        "PAYMENT_REQUIRED",
        "Please upgrade to premium"
    ))
}

// å¸¦è¯¦ç»†ä¿¡æ¯
#[get("/rate-limit")]
async fn rate_limited() -> AppResult<()> {
    Err(AppError::custom_with_details(
        StatusCode::TOO_MANY_REQUESTS,
        "RATE_LIMIT_EXCEEDED",
        "Too many requests",
        json!({
            "limit": 100,
            "remaining": 0,
            "reset_at": 1234567890
        })
    ))
}
```

### ä¸ºè‡ªå®šä¹‰é”™è¯¯å®ç° From

```rust
// è‡ªå®šä¹‰ä¸šåŠ¡é”™è¯¯
enum BusinessError {
    InsufficientBalance,
    ProductOutOfStock,
    InvalidCoupon(String),
}

impl From<BusinessError> for AppError {
    fn from(err: BusinessError) -> Self {
        match err {
            BusinessError::InsufficientBalance => {
                AppError::BadRequest("Insufficient balance".into())
            }
            BusinessError::ProductOutOfStock => {
                AppError::Conflict("Product is out of stock".into())
            }
            BusinessError::InvalidCoupon(code) => {
                AppError::BadRequest(format!("Invalid coupon code: {}", code))
            }
        }
    }
}

// ä½¿ç”¨
#[post("/orders")]
async fn create_order(Json(data): Json<CreateOrder>) -> AppResult<Json<Order>> {
    let order = business_logic::create_order(data)?;  // BusinessError è‡ªåŠ¨è½¬æ¢
    Ok(Json(order))
}
```

## ValidationErrorDetail è¾…åŠ©å‡½æ•°

å¿«é€Ÿåˆ›å»ºéªŒè¯é”™è¯¯ï¼š

```rust
use miko::ValidationErrorDetail;

// å¿…å¡«å­—æ®µ
let error = ValidationErrorDetail::required("email");

// æ ¼å¼é”™è¯¯
let error = ValidationErrorDetail::invalid_format("email", "valid email");

// é•¿åº¦é”™è¯¯
let error = ValidationErrorDetail::invalid_length("name", 3, 50);

// æœ€å°å€¼
let error = ValidationErrorDetail::min_value("age", 18);

// æœ€å¤§å€¼
let error = ValidationErrorDetail::max_value("age", 120);

// è‡ªå®šä¹‰
let error = ValidationErrorDetail::new(
    "field_name",
    "Custom error message",
    "CUSTOM_CODE"
);
```

## Trace ID

æ¡†æ¶ä¼š**è‡ªåŠ¨**ä¸ºæ¯ä¸ªè¯·æ±‚è®¾ç½® Trace IDï¼Œå¹¶åœ¨é”™è¯¯å“åº”ä¸­åŒ…å«å®ƒã€‚

### è‡ªåŠ¨ç”Ÿæˆ

Trace ID çš„ç”Ÿæˆè§„åˆ™ï¼ˆæŒ‰ä¼˜å…ˆçº§ï¼‰ï¼š

1. ä» `x-trace-id` è¯·æ±‚å¤´è·å–
2. ä» `x-request-id` è¯·æ±‚å¤´è·å–
3. è‡ªåŠ¨ç”Ÿæˆï¼ˆæ ¼å¼ï¼š`trace-{timestamp}-{thread_id}`ï¼‰

### åœ¨ä»£ç ä¸­è·å–

ä½ å¯ä»¥åœ¨ Handler ä¸­è·å–å½“å‰è¯·æ±‚çš„ Trace IDï¼š

```rust
use miko::error::get_trace_id;

#[get("/users")]
async fn list_users() -> AppResult<Json<Vec<User>>> {
    // è·å–å½“å‰è¯·æ±‚çš„ trace_id
    let trace_id = get_trace_id().unwrap_or_default();

    // å¯ä»¥ç”¨äºæ—¥å¿—è®°å½•
    tracing::info!(trace_id = %trace_id, "Querying users");

    let users = db.query_users()?;
    Ok(Json(users))
}
```

### é”™è¯¯å“åº”ä¸­è‡ªåŠ¨åŒ…å«

æ‰€æœ‰é”™è¯¯å“åº”éƒ½ä¼šè‡ªåŠ¨åŒ…å« Trace IDï¼š

```json
{
    "status": 500,
    "error": "DATABASE_ERROR",
    "message": "Query failed",
    "trace_id": "trace-123abc-ThreadId(5)",  // è‡ªåŠ¨æ·»åŠ 
    "timestamp": 1234567890
}
```

> **æ³¨æ„**ï¼š
> - æ¡†æ¶ä¼šè‡ªåŠ¨è®¾ç½®å’Œæ¸…ç† Trace IDï¼Œä½ **æ— éœ€æ‰‹åŠ¨è°ƒç”¨** `set_trace_id()` æˆ– `clear_trace_id()`
> - å¦‚æœä½ çš„å®¢æˆ·ç«¯å‘é€äº† `x-trace-id` è¯·æ±‚å¤´ï¼Œæ¡†æ¶ä¼šä½¿ç”¨å®ƒï¼ˆç”¨äºåˆ†å¸ƒå¼è¿½è¸ªï¼‰

è¯¦è§ [é«˜çº§ç‰¹æ€§ - Trace ID](é«˜çº§ç‰¹æ€§.md#trace-id) äº†è§£æ›´å¤šç”¨æ³•ã€‚

## é”™è¯¯æ—¥å¿—

5xx é”™è¯¯ä¼šè‡ªåŠ¨è®°å½•æ—¥å¿—ï¼š

```rust
// æœåŠ¡å™¨é”™è¯¯ä¼šè‡ªåŠ¨è®°å½•
#[get("/crash")]
async fn crash() -> AppResult<()> {
    Err(AppError::InternalServerError("Something went wrong".into()))
    // è‡ªåŠ¨è¾“å‡ºæ—¥å¿—ï¼šerror_code=INTERNAL_SERVER_ERROR message="Something went wrong" trace_id=...
}

// 4xx å®¢æˆ·ç«¯é”™è¯¯ä¸ä¼šè®°å½•æ—¥å¿—ï¼ˆè®¤ä¸ºæ˜¯æ­£å¸¸ä¸šåŠ¡ï¼‰
#[get("/not-found")]
async fn not_found() -> AppResult<()> {
    Err(AppError::NotFound("Resource not found".into()))
    // ä¸è®°å½•æ—¥å¿—
}
```

## ä¸‹ä¸€æ­¥

- âœ… å­¦ä¹  [æ•°æ®éªŒè¯](æ•°æ®éªŒè¯.md) è‡ªåŠ¨éªŒè¯è¾“å…¥
- ğŸ” äº†è§£ [è¯·æ±‚æå–å™¨](è¯·æ±‚æå–å™¨.md) çš„é”™è¯¯å¤„ç†
- ğŸ“¤ æŒæ¡ [å“åº”å¤„ç†](å“åº”å¤„ç†.md) çš„å„ç§æ–¹å¼
- ğŸ” ä½¿ç”¨ [ä¸­é—´ä»¶](ä¸­é—´ä»¶ä¸å±‚.md) æ·»åŠ å…¨å±€é”™è¯¯å¤„ç†
