# 错误处理

Miko 提供了统一的错误处理机制，让你可以优雅地处理各种错误情况，并返回一致的 JSON 格式错误响应。

## 核心类型

### AppError

框架提供的统一错误类型，涵盖常见的 HTTP 错误场景：

```rust
pub enum AppError {
    // 客户端错误 (4xx)
    BadRequest(String),           // 400
    Unauthorized(String),          // 401
    Forbidden(String),             // 403
    NotFound(String),              // 404
    Conflict(String),              // 409
    UnprocessableEntity(String),   // 422
    TooManyRequests(String),       // 429

    // 服务器错误 (5xx)
    InternalServerError(String),   // 500
    BadGateway(String),            // 502
    ServiceUnavailable(String),    // 503
    GatewayTimeout(String),        // 504

    // 具体错误类型
    JsonParseError(serde_json::Error),
    UrlEncodedParseError(serde_urlencoded::de::Error),
    ValidationError(Vec<ValidationErrorDetail>),
    DatabaseError(String),
    IoError(std::io::Error),
    Timeout(String),
    ExternalServiceError { service: String, message: String },

    // 自定义错误
    Custom {
        status: StatusCode,
        error_code: String,
        message: String,
        details: Option<serde_json::Value>,
    },
}
```

### AppResult

类型别名，简化错误处理：

```rust
pub type AppResult<T> = Result<T, AppError>;
```

### ErrorResponse

统一的错误响应格式：

```rust
{
    "status": 404,
    "error": "NOT_FOUND",
    "message": "User 123 not found",
    "details": null,
    "trace_id": "req-abc-123",
    "timestamp": 1234567890
}
```

## 基础用法

### 返回错误

在 Handler 中返回 `AppResult`：

```rust
use miko::{*, AppResult, AppError};

#[get("/users/{id}")]
async fn get_user(#[path] id: u32) -> AppResult<Json<User>> {
    let user = db.find_user(id)
        .ok_or(AppError::NotFound(format!("User {} not found", id)))?;

    Ok(Json(user))
}
```

### 使用 ? 操作符

```rust
#[post("/users")]
async fn create_user(Json(data): Json<CreateUser>) -> AppResult<Json<User>> {
    // 自动转换各种错误
    let user = db.create_user(data)?;  // io::Error -> AppError
    Ok(Json(user))
}
```

## 常见错误场景

### 404 Not Found

资源不存在：

```rust
#[get("/users/{id}")]
async fn get_user(#[path] id: u32) -> AppResult<Json<User>> {
    let user = db.find_user(id)
        .ok_or_else(|| AppError::NotFound(format!("User {} not found", id)))?;
    Ok(Json(user))
}
```

响应示例：

```json
{
    "status": 404,
    "error": "NOT_FOUND",
    "message": "User 123 not found",
    "timestamp": 1234567890
}
```

### 400 Bad Request

请求参数错误：

```rust
#[post("/users")]
async fn create_user(Json(data): Json<CreateUser>) -> AppResult<Json<User>> {
    if data.email.is_empty() {
        return Err(AppError::BadRequest("Email is required".into()));
    }

    if !data.email.contains('@') {
        return Err(AppError::BadRequest("Invalid email format".into()));
    }

    Ok(Json(db.create_user(data)?))
}
```

### 401 Unauthorized

未认证：

```rust
#[get("/profile")]
async fn get_profile(headers: HeaderMap) -> AppResult<Json<Profile>> {
    let token = headers
        .get("authorization")
        .and_then(|v| v.to_str().ok())
        .ok_or_else(|| AppError::Unauthorized("Missing auth token".into()))?;

    let user = verify_token(token)
        .ok_or_else(|| AppError::Unauthorized("Invalid or expired token".into()))?;

    Ok(Json(get_profile_for_user(user)))
}
```

### 403 Forbidden

已认证但无权限：

```rust
#[delete("/posts/{id}")]
async fn delete_post(
    #[path] id: u32,
    user: AuthUser,  // 自定义提取器
) -> AppResult<StatusCode> {
    let post = db.find_post(id)
        .ok_or(AppError::NotFound("Post not found".into()))?;

    if post.author_id != user.id && !user.is_admin {
        return Err(AppError::Forbidden("You don't have permission to delete this post".into()));
    }

    db.delete_post(id)?;
    Ok(StatusCode::NO_CONTENT)
}
```

### 409 Conflict

资源冲突：

```rust
#[post("/users")]
async fn create_user(Json(data): Json<CreateUser>) -> AppResult<Json<User>> {
    if db.email_exists(&data.email) {
        return Err(AppError::Conflict("Email already exists".into()));
    }

    if db.username_exists(&data.username) {
        return Err(AppError::Conflict("Username already taken".into()));
    }

    Ok(Json(db.create_user(data)?))
}
```

### 422 Validation Error

数据验证失败：

> 推荐使用 `ValidatedJson` 自动验证，详见 [数据验证](数据验证.md)

```rust
use miko::ValidationErrorDetail;

#[post("/users")]
async fn create_user(Json(data): Json<CreateUser>) -> AppResult<Json<User>> {
    let mut errors = Vec::new();

    if data.name.len() < 3 {
        errors.push(ValidationErrorDetail::invalid_length("name", 3, 50));
    }

    if !data.email.contains('@') {
        errors.push(ValidationErrorDetail::invalid_format("email", "valid email address"));
    }

    if data.age < 18 {
        errors.push(ValidationErrorDetail::min_value("age", 18));
    }

    if !errors.is_empty() {
        return Err(AppError::ValidationError(errors));
    }

    Ok(Json(db.create_user(data)?))
}
```

响应示例：

```json
{
    "status": 422,
    "error": "VALIDATION_ERROR",
    "message": "Request validation failed",
    "details": {
        "fields": [
            {
                "field": "name",
                "message": "name length must be between 3 and 50",
                "code": "VALIDATION_FAILED"
            },
            {
                "field": "email",
                "message": "email has invalid format, expected: valid email address",
                "code": "VALIDATION_FAILED"
            }
        ]
    },
    "timestamp": 1234567890
}
```

### 500 Internal Server Error

服务器内部错误：

```rust
#[get("/users")]
async fn list_users() -> AppResult<Json<Vec<User>>> {
    let users = db.query_users()
        .map_err(|e| AppError::DatabaseError(format!("Failed to query users: {}", e)))?;

    Ok(Json(users))
}
```

## 自动错误转换

框架为常见错误类型实现了 `From` trait：

```rust
// std::io::Error
let data = tokio::fs::read("file.txt").await?;  // 自动转换

// serde_json::Error
let value: MyData = serde_json::from_str(&json)?;  // 自动转换

// multer::Error (文件上传)
while let Some(field) = multipart.next_field().await? {  // 自动转换
    // ...
}
```

支持的自动转换：

| 错误类型 | 转换为 |
|---------|--------|
| `std::io::Error` | `AppError::IoError` |
| `serde_json::Error` | `AppError::JsonParseError` |
| `serde_urlencoded::de::Error` | `AppError::UrlEncodedParseError` |
| `multer::Error` | `AppError::MultipartParseError` |
| `anyhow::Error` | `AppError::InternalServerError` |
| `garde::Report` | `AppError::ValidationError` (需要 `validation` feature) |

## 自定义错误

### 使用 Custom 变体

完全自定义错误响应：

```rust
use hyper::StatusCode;
use serde_json::json;

#[get("/custom-error")]
async fn handler() -> AppResult<()> {
    Err(AppError::custom(
        StatusCode::PAYMENT_REQUIRED,
        "PAYMENT_REQUIRED",
        "Please upgrade to premium"
    ))
}

// 带详细信息
#[get("/rate-limit")]
async fn rate_limited() -> AppResult<()> {
    Err(AppError::custom_with_details(
        StatusCode::TOO_MANY_REQUESTS,
        "RATE_LIMIT_EXCEEDED",
        "Too many requests",
        json!({
            "limit": 100,
            "remaining": 0,
            "reset_at": 1234567890
        })
    ))
}
```

### 为自定义错误实现 From

```rust
// 自定义业务错误
enum BusinessError {
    InsufficientBalance,
    ProductOutOfStock,
    InvalidCoupon(String),
}

impl From<BusinessError> for AppError {
    fn from(err: BusinessError) -> Self {
        match err {
            BusinessError::InsufficientBalance => {
                AppError::BadRequest("Insufficient balance".into())
            }
            BusinessError::ProductOutOfStock => {
                AppError::Conflict("Product is out of stock".into())
            }
            BusinessError::InvalidCoupon(code) => {
                AppError::BadRequest(format!("Invalid coupon code: {}", code))
            }
        }
    }
}

// 使用
#[post("/orders")]
async fn create_order(Json(data): Json<CreateOrder>) -> AppResult<Json<Order>> {
    let order = business_logic::create_order(data)?;  // BusinessError 自动转换
    Ok(Json(order))
}
```

## ValidationErrorDetail 辅助函数

快速创建验证错误：

```rust
use miko::ValidationErrorDetail;

// 必填字段
let error = ValidationErrorDetail::required("email");

// 格式错误
let error = ValidationErrorDetail::invalid_format("email", "valid email");

// 长度错误
let error = ValidationErrorDetail::invalid_length("name", 3, 50);

// 最小值
let error = ValidationErrorDetail::min_value("age", 18);

// 最大值
let error = ValidationErrorDetail::max_value("age", 120);

// 自定义
let error = ValidationErrorDetail::new(
    "field_name",
    "Custom error message",
    "CUSTOM_CODE"
);
```

## Trace ID

框架会**自动**为每个请求设置 Trace ID，并在错误响应中包含它。

### 自动生成

Trace ID 的生成规则（按优先级）：

1. 从 `x-trace-id` 请求头获取
2. 从 `x-request-id` 请求头获取
3. 自动生成（格式：`trace-{timestamp}-{thread_id}`）

### 在代码中获取

你可以在 Handler 中获取当前请求的 Trace ID：

```rust
use miko::error::get_trace_id;

#[get("/users")]
async fn list_users() -> AppResult<Json<Vec<User>>> {
    // 获取当前请求的 trace_id
    let trace_id = get_trace_id().unwrap_or_default();

    // 可以用于日志记录
    tracing::info!(trace_id = %trace_id, "Querying users");

    let users = db.query_users()?;
    Ok(Json(users))
}
```

### 错误响应中自动包含

所有错误响应都会自动包含 Trace ID：

```json
{
    "status": 500,
    "error": "DATABASE_ERROR",
    "message": "Query failed",
    "trace_id": "trace-123abc-ThreadId(5)",  // 自动添加
    "timestamp": 1234567890
}
```

> **注意**：
> - 框架会自动设置和清理 Trace ID，你**无需手动调用** `set_trace_id()` 或 `clear_trace_id()`
> - 如果你的客户端发送了 `x-trace-id` 请求头，框架会使用它（用于分布式追踪）

详见 [高级特性 - Trace ID](高级特性.md#trace-id) 了解更多用法。

## 错误日志

5xx 错误会自动记录日志：

```rust
// 服务器错误会自动记录
#[get("/crash")]
async fn crash() -> AppResult<()> {
    Err(AppError::InternalServerError("Something went wrong".into()))
    // 自动输出日志：error_code=INTERNAL_SERVER_ERROR message="Something went wrong" trace_id=...
}

// 4xx 客户端错误不会记录日志（认为是正常业务）
#[get("/not-found")]
async fn not_found() -> AppResult<()> {
    Err(AppError::NotFound("Resource not found".into()))
    // 不记录日志
}
```

## 下一步

- ✅ 学习 [数据验证](数据验证.md) 自动验证输入
- 🔍 了解 [请求提取器](请求提取器.md) 的错误处理
- 📤 掌握 [响应处理](响应处理.md) 的各种方式
- 🔐 使用 [中间件](中间件与层.md) 添加全局错误处理
