# 中间件与层

Miko 基于 Tower 的 Layer 机制提供中间件功能。

## 核心概念

### Layer 延迟应用

Router 上设置的 Layer **不会立即应用**,而是在以下时机应用:
- `into_tower_service()` 调用时
- `merge()` 合并路由时
- `nest()` 嵌套路由时

```rust
use miko::*;
use tower_http::timeout::TimeoutLayer;
use std::time::Duration;

let mut router = Router::new();
router.with_layer(TimeoutLayer::new(Duration::from_secs(30)));  // 注册 Layer
// ⚠️ 此时 Layer 还未应用

// ✅ Layer 在这里应用
let svc = router.into_tower_service();
```

## Router 级别 Layer

### with_layer 方法

使用 `with_layer` 为整个 Router 添加中间件:

```rust
use miko::*;
use tower_http::{
    trace::TraceLayer,
    timeout::TimeoutLayer,
    compression::CompressionLayer,
};
use std::time::Duration;

#[get("/api/users")]
async fn users() -> &'static str {
    "users"
}

#[miko]
async fn main() {
    let mut router = Router::new();
    
    // 链式添加多个 Layer
    router
        .with_layer(TraceLayer::new_for_http())
        .with_layer(TimeoutLayer::new(Duration::from_secs(30)))
        .with_layer(CompressionLayer::new());
}
```

### 使用 ServiceBuilder

Tower 的 `ServiceBuilder` 可以组合多个 Layer:

```rust
use tower::ServiceBuilder;
use tower_http::{trace::TraceLayer, compression::CompressionLayer};
use std::time::Duration;

#[miko]
async fn main() {
    let middleware = ServiceBuilder::new()
        .layer(TraceLayer::new_for_http())
        .layer(CompressionLayer::new())
        .timeout(Duration::from_secs(30));
    
    let mut router = Router::new();
    router.with_layer(middleware);
}
```

## Handler 级别 Layer

### WithState trait

`WithState` trait 让 handler 可以立即获得 state 并包装为 Service,然后链式调用 `LayerExt`:

```rust
use miko::*;
use miko::endpoint::{WithState, LayerExt};
use tower_http::timeout::TimeoutLayer;
use std::time::Duration;
use std::sync::Arc;

struct AppState {
    db: Database,
}

async fn get_user(State(state): State<Arc<AppState>>) -> String {
    format!("User from {:?}", state.db)
}

#[tokio::main]
async fn main() {
    let state = Arc::new(AppState { db: Database::new() });
    
    // 推荐: 使用 router.state.clone()
    let endpoint = get_user
        .with_state(state.clone())  // 立即赋予 state 并包装为 Service
        .layer(TimeoutLayer::new(Duration::from_secs(30)));  // 链式调用 layer
    
    let router = Router::with_state(state)
        .get_service("/user", endpoint);
}
```

### LayerExt trait

`LayerExt` 为 Service 提供链式 `.layer()` 方法:

```rust
use miko::endpoint::LayerExt;
use tower_http::{timeout::TimeoutLayer, compression::CompressionLayer};
use std::time::Duration;

async fn handler() -> String {
    "Hello".to_string()
}

#[tokio::main]
async fn main() {
    let router = Router::new();
    let state = router.state.clone();
    
    // 链式调用多个 layer
    let endpoint = handler
        .with_state(state)
        .layer(TimeoutLayer::new(Duration::from_secs(30)))
        .layer(CompressionLayer::new());
    
    router.get_service("/api", endpoint);
}
```

## CORS 支持

### cors_any 方法

> **需要 `ext` feature**

框架提供 `cors_any()` 方法快速启用 CORS（开发用）:

```rust
use miko::*;

#[miko]
async fn main() {
    let mut router = Router::new();
    
    // 允许任意跨域（等同于 CorsLayer::permissive）
    router.cors_any();
}
```

### 自定义 CORS

使用 `tower-http` 的 `CorsLayer`（**无需** `ext` feature）:

```rust
use tower_http::cors::CorsLayer;
use http::{Method, HeaderValue};

#[miko]
async fn main() {
    let cors = CorsLayer::new()
        .allow_origin("http://localhost:3000".parse::<HeaderValue>().unwrap())
        .allow_methods([Method::GET, Method::POST]);
    
    let mut router = Router::new();
    router.with_layer(cors);
}
```

## 模块级 Layer

使用 `#[layer]` 宏为模块内所有路由添加中间件:

```rust
use tower_http::timeout::TimeoutLayer;
use std::time::Duration;

#[layer(TimeoutLayer::new(Duration::from_secs(30)))]
mod api {
    #[get("/users")]
    async fn list_users() -> &'static str {
        "users"  // 自动应用 30 秒超时
    }
    
    #[get("/posts")]
    async fn list_posts() -> &'static str {
        "posts"  // 自动应用 30 秒超时
    }
}
```

## 函数级 Layer

使用 `#[layer]` 宏为单个函数添加中间件:

```rust
use tower_http::timeout::TimeoutLayer;
use tower_http::compression::CompressionLayer;
use std::time::Duration;

// 单个 layer
#[get("/users")]
#[layer(TimeoutLayer::new(Duration::from_secs(30)))]
async fn list_users() -> &'static str {
    "users"
}

// 多个 layer（从上到下声明,从内到外应用）
#[post("/data")]
#[layer(TimeoutLayer::new(Duration::from_secs(30)))]
#[layer(CompressionLayer::new())]
async fn process_data() -> &'static str {
    // 调用链: CompressionLayer -> TimeoutLayer -> handler
    "processed"
}
```

## Tower 中间件

Miko 兼容 Tower 生态的中间件。常用中间件可查阅 [tower-http 文档](https://docs.rs/tower-http/)。

### ServiceBuilder

Tower 的 `ServiceBuilder` 可以方便地组合多个中间件:

```rust
use tower::ServiceBuilder;
use tower_http::{
    trace::TraceLayer,
    compression::CompressionLayer,
    timeout::TimeoutLayer,
};
use std::time::Duration;

#[miko]
async fn main() {
    let middleware = ServiceBuilder::new()
        .layer(TraceLayer::new_for_http())
        .layer(CompressionLayer::new())
        .layer(TimeoutLayer::new(Duration::from_secs(30)));
    
    let mut router = Router::new();
    router.with_layer(middleware);
}
```

## 下一步

- 🔍 了解 [错误处理](错误处理.md) 统一错误格式
- 📖 学习 [响应处理](响应处理.md) 构造响应
- 🚀 查看 [高级特性](高级特性.md) 更多功能
