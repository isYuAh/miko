# ä¸­é—´ä»¶ä¸å±‚

Miko åŸºäº Tower çš„ Layer æœºåˆ¶æä¾›ä¸­é—´ä»¶åŠŸèƒ½ã€‚

## æ ¸å¿ƒæ¦‚å¿µ

### Layer å»¶è¿Ÿåº”ç”¨

Router ä¸Šè®¾ç½®çš„ Layer **ä¸ä¼šç«‹å³åº”ç”¨**,è€Œæ˜¯åœ¨ä»¥ä¸‹æ—¶æœºåº”ç”¨:
- `into_tower_service()` è°ƒç”¨æ—¶
- `merge()` åˆå¹¶è·¯ç”±æ—¶
- `nest()` åµŒå¥—è·¯ç”±æ—¶

```rust
use miko::*;
use tower_http::timeout::TimeoutLayer;
use std::time::Duration;

let mut router = Router::new();
router.with_layer(TimeoutLayer::new(Duration::from_secs(30)));  // æ³¨å†Œ Layer
// âš ï¸ æ­¤æ—¶ Layer è¿˜æœªåº”ç”¨

// âœ… Layer åœ¨è¿™é‡Œåº”ç”¨
let svc = router.into_tower_service();
```

## Router çº§åˆ« Layer

### with_layer æ–¹æ³•

ä½¿ç”¨ `with_layer` ä¸ºæ•´ä¸ª Router æ·»åŠ ä¸­é—´ä»¶:

```rust
use miko::*;
use tower_http::{
    trace::TraceLayer,
    timeout::TimeoutLayer,
    compression::CompressionLayer,
};
use std::time::Duration;

#[get("/api/users")]
async fn users() -> &'static str {
    "users"
}

#[miko]
async fn main() {
    let mut router = Router::new();
    
    // é“¾å¼æ·»åŠ å¤šä¸ª Layer
    router
        .with_layer(TraceLayer::new_for_http())
        .with_layer(TimeoutLayer::new(Duration::from_secs(30)))
        .with_layer(CompressionLayer::new());
}
```

### ä½¿ç”¨ ServiceBuilder

Tower çš„ `ServiceBuilder` å¯ä»¥ç»„åˆå¤šä¸ª Layer:

```rust
use tower::ServiceBuilder;
use tower_http::{trace::TraceLayer, compression::CompressionLayer};
use std::time::Duration;

#[miko]
async fn main() {
    let middleware = ServiceBuilder::new()
        .layer(TraceLayer::new_for_http())
        .layer(CompressionLayer::new())
        .timeout(Duration::from_secs(30));
    
    let mut router = Router::new();
    router.with_layer(middleware);
}
```

## Handler çº§åˆ« Layer

### WithState trait

`WithState` trait è®© handler å¯ä»¥ç«‹å³è·å¾— state å¹¶åŒ…è£…ä¸º Service,ç„¶åé“¾å¼è°ƒç”¨ `LayerExt`:

```rust
use miko::*;
use miko::endpoint::{WithState, LayerExt};
use tower_http::timeout::TimeoutLayer;
use std::time::Duration;
use std::sync::Arc;

struct AppState {
    db: Database,
}

async fn get_user(State(state): State<Arc<AppState>>) -> String {
    format!("User from {:?}", state.db)
}

#[tokio::main]
async fn main() {
    let state = Arc::new(AppState { db: Database::new() });
    
    // æ¨è: ä½¿ç”¨ router.state.clone()
    let endpoint = get_user
        .with_state(state.clone())  // ç«‹å³èµ‹äºˆ state å¹¶åŒ…è£…ä¸º Service
        .layer(TimeoutLayer::new(Duration::from_secs(30)));  // é“¾å¼è°ƒç”¨ layer
    
    let router = Router::with_state(state)
        .get_service("/user", endpoint);
}
```

### LayerExt trait

`LayerExt` ä¸º Service æä¾›é“¾å¼ `.layer()` æ–¹æ³•:

```rust
use miko::endpoint::LayerExt;
use tower_http::{timeout::TimeoutLayer, compression::CompressionLayer};
use std::time::Duration;

async fn handler() -> String {
    "Hello".to_string()
}

#[tokio::main]
async fn main() {
    let router = Router::new();
    let state = router.state.clone();
    
    // é“¾å¼è°ƒç”¨å¤šä¸ª layer
    let endpoint = handler
        .with_state(state)
        .layer(TimeoutLayer::new(Duration::from_secs(30)))
        .layer(CompressionLayer::new());
    
    router.get_service("/api", endpoint);
}
```

## CORS æ”¯æŒ

### cors_any æ–¹æ³•

> **éœ€è¦ `ext` feature**

æ¡†æ¶æä¾› `cors_any()` æ–¹æ³•å¿«é€Ÿå¯ç”¨ CORSï¼ˆå¼€å‘ç”¨ï¼‰:

```rust
use miko::*;

#[miko]
async fn main() {
    let mut router = Router::new();
    
    // å…è®¸ä»»æ„è·¨åŸŸï¼ˆç­‰åŒäº CorsLayer::permissiveï¼‰
    router.cors_any();
}
```

### è‡ªå®šä¹‰ CORS

ä½¿ç”¨ `tower-http` çš„ `CorsLayer`ï¼ˆ**æ— éœ€** `ext` featureï¼‰:

```rust
use tower_http::cors::CorsLayer;
use http::{Method, HeaderValue};

#[miko]
async fn main() {
    let cors = CorsLayer::new()
        .allow_origin("http://localhost:3000".parse::<HeaderValue>().unwrap())
        .allow_methods([Method::GET, Method::POST]);
    
    let mut router = Router::new();
    router.with_layer(cors);
}
```

## æ¨¡å—çº§ Layer

ä½¿ç”¨ `#[layer]` å®ä¸ºæ¨¡å—å†…æ‰€æœ‰è·¯ç”±æ·»åŠ ä¸­é—´ä»¶:

```rust
use tower_http::timeout::TimeoutLayer;
use std::time::Duration;

#[layer(TimeoutLayer::new(Duration::from_secs(30)))]
mod api {
    #[get("/users")]
    async fn list_users() -> &'static str {
        "users"  // è‡ªåŠ¨åº”ç”¨ 30 ç§’è¶…æ—¶
    }
    
    #[get("/posts")]
    async fn list_posts() -> &'static str {
        "posts"  // è‡ªåŠ¨åº”ç”¨ 30 ç§’è¶…æ—¶
    }
}
```

## å‡½æ•°çº§ Layer

ä½¿ç”¨ `#[layer]` å®ä¸ºå•ä¸ªå‡½æ•°æ·»åŠ ä¸­é—´ä»¶:

```rust
use tower_http::timeout::TimeoutLayer;
use tower_http::compression::CompressionLayer;
use std::time::Duration;

// å•ä¸ª layer
#[get("/users")]
#[layer(TimeoutLayer::new(Duration::from_secs(30)))]
async fn list_users() -> &'static str {
    "users"
}

// å¤šä¸ª layerï¼ˆä»ä¸Šåˆ°ä¸‹å£°æ˜,ä»å†…åˆ°å¤–åº”ç”¨ï¼‰
#[post("/data")]
#[layer(TimeoutLayer::new(Duration::from_secs(30)))]
#[layer(CompressionLayer::new())]
async fn process_data() -> &'static str {
    // è°ƒç”¨é“¾: CompressionLayer -> TimeoutLayer -> handler
    "processed"
}
```

## Tower ä¸­é—´ä»¶

Miko å…¼å®¹ Tower ç”Ÿæ€çš„ä¸­é—´ä»¶ã€‚å¸¸ç”¨ä¸­é—´ä»¶å¯æŸ¥é˜… [tower-http æ–‡æ¡£](https://docs.rs/tower-http/)ã€‚

### ServiceBuilder

Tower çš„ `ServiceBuilder` å¯ä»¥æ–¹ä¾¿åœ°ç»„åˆå¤šä¸ªä¸­é—´ä»¶:

```rust
use tower::ServiceBuilder;
use tower_http::{
    trace::TraceLayer,
    compression::CompressionLayer,
    timeout::TimeoutLayer,
};
use std::time::Duration;

#[miko]
async fn main() {
    let middleware = ServiceBuilder::new()
        .layer(TraceLayer::new_for_http())
        .layer(CompressionLayer::new())
        .layer(TimeoutLayer::new(Duration::from_secs(30)));
    
    let mut router = Router::new();
    router.with_layer(middleware);
}
```

## ä¸‹ä¸€æ­¥

- ğŸ” äº†è§£ [é”™è¯¯å¤„ç†](é”™è¯¯å¤„ç†.md) ç»Ÿä¸€é”™è¯¯æ ¼å¼
- ğŸ“– å­¦ä¹  [å“åº”å¤„ç†](å“åº”å¤„ç†.md) æ„é€ å“åº”
- ğŸš€ æŸ¥çœ‹ [é«˜çº§ç‰¹æ€§](é«˜çº§ç‰¹æ€§.md) æ›´å¤šåŠŸèƒ½
