# ä¸­é—´ä»¶ä¸å±‚

Miko åŸºäº Tower çš„ Layer æœºåˆ¶æä¾›ä¸­é—´ä»¶åŠŸèƒ½ã€‚

## æ ¸å¿ƒæ¦‚å¿µ

### Layer å»¶è¿Ÿåº”ç”¨

Router ä¸Šè®¾ç½®çš„ Layer **ä¸ä¼šç«‹å³åº”ç”¨**,è€Œæ˜¯åœ¨ä»¥ä¸‹æ—¶æœºåº”ç”¨:
- `into_tower_service()` è°ƒç”¨æ—¶
- `merge()` åˆå¹¶è·¯ç”±æ—¶
- `nest()` åµŒå¥—è·¯ç”±æ—¶

```rust
use miko::*;
use miko::macros::*;
use tower_http::timeout::TimeoutLayer;
use std::time::Duration;

let mut router = Router::new();
router.with_layer(TimeoutLayer::new(Duration::from_secs(30)));  // æ³¨å†Œ Layer
// âš ï¸ æ­¤æ—¶ Layer è¿˜æœªåº”ç”¨

// âœ… Layer åœ¨è¿™é‡Œåº”ç”¨
let svc = router.into_tower_service();
```

## Router çº§åˆ« Layer

### with_layer æ–¹æ³•

ä½¿ç”¨ `with_layer` ä¸ºæ•´ä¸ª Router æ·»åŠ ä¸­é—´ä»¶:

```rust
use miko::*;
use miko::macros::*;
use tower_http::{
    trace::TraceLayer,
    timeout::TimeoutLayer,
    compression::CompressionLayer,
};
use std::time::Duration;

#[get("/api/users")]
async fn users() -> &'static str {
    "users"
}

#[miko]
async fn main() {
    let mut router = Router::new();

    // é“¾å¼æ·»åŠ å¤šä¸ª Layer
    router
        .with_layer(TraceLayer::new_for_http())
        .with_layer(TimeoutLayer::new(Duration::from_secs(30)))
        .with_layer(CompressionLayer::new());
}
```

### ä½¿ç”¨ ServiceBuilder

Tower çš„ `ServiceBuilder` å¯ä»¥ç»„åˆå¤šä¸ª Layer:

```rust
use tower::ServiceBuilder;
use tower_http::{trace::TraceLayer, compression::CompressionLayer};
use std::time::Duration;

#[miko]
async fn main() {
    let middleware = ServiceBuilder::new()
        .layer(TraceLayer::new_for_http())
        .layer(CompressionLayer::new())
        .timeout(Duration::from_secs(30));

    let mut router = Router::new();
    router.with_layer(middleware);
}
```

## Handler çº§åˆ« Layer

### WithState trait

`WithState` trait è®© handler å¯ä»¥ç«‹å³è·å¾— state å¹¶åŒ…è£…ä¸º Service,ç„¶åé“¾å¼è°ƒç”¨ `LayerExt`:

```rust
use miko::*;
use miko::macros::*;
use miko::endpoint::{WithState, LayerExt};
use tower_http::timeout::TimeoutLayer;
use std::time::Duration;
use std::sync::Arc;

struct AppState {
    db: Database,
}

async fn get_user(State(state): State<Arc<AppState>>) -> String {
    format!("User from {:?}", state.db)
}

#[tokio::main]
async fn main() {
    let state = Arc::new(AppState { db: Database::new() });

    // æ¨è: ä½¿ç”¨ router.state.clone()
    let endpoint = get_user
        .with_state(state.clone())  // ç«‹å³èµ‹äºˆ state å¹¶åŒ…è£…ä¸º Service
        .layer(TimeoutLayer::new(Duration::from_secs(30)));  // é“¾å¼è°ƒç”¨ layer

    let router = Router::with_state(state)
        .get_service("/user", endpoint);
}
```

### LayerExt trait

`LayerExt` ä¸º Service æä¾›é“¾å¼ `.layer()` æ–¹æ³•:

```rust
use miko::endpoint::LayerExt;
use miko::macros::*;
use tower_http::{timeout::TimeoutLayer, compression::CompressionLayer};
use std::time::Duration;

async fn handler() -> String {
    "Hello".to_string()
}

#[tokio::main]
async fn main() {
    let router = Router::new();
    let state = router.state.clone();

    // é“¾å¼è°ƒç”¨å¤šä¸ª layer
    let endpoint = handler
        .with_state(state)
        .layer(TimeoutLayer::new(Duration::from_secs(30)))
        .layer(CompressionLayer::new());

    router.get_service("/api", endpoint);
}
```

## CORS æ”¯æŒ

### cors_any æ–¹æ³•

> **éœ€è¦ `ext` feature**

æ¡†æ¶æä¾› `cors_any()` æ–¹æ³•å¿«é€Ÿå¯ç”¨ CORSï¼ˆå¼€å‘ç”¨ï¼‰:

```rust
use miko::*;
use miko::macros::*;

#[miko]
async fn main() {
    let mut router = Router::new();

    // å…è®¸ä»»æ„è·¨åŸŸï¼ˆç­‰åŒäº CorsLayer::permissiveï¼‰
    router.cors_any();
}
```

### è‡ªå®šä¹‰ CORS

ä½¿ç”¨ `tower-http` çš„ `CorsLayer`ï¼ˆ**æ— éœ€** `ext` featureï¼‰:

```rust
use tower_http::cors::CorsLayer;
use http::{Method, HeaderValue};

#[miko]
async fn main() {
    let cors = CorsLayer::new()
        .allow_origin("http://localhost:3000".parse::<HeaderValue>().unwrap())
        .allow_methods([Method::GET, Method::POST]);

    let mut router = Router::new();
    router.with_layer(cors);
}
```

## æ¨¡å—çº§ Layer

ä½¿ç”¨ `#[layer]` å®ä¸ºæ¨¡å—å†…æ‰€æœ‰è·¯ç”±æ·»åŠ ä¸­é—´ä»¶:

```rust
use tower_http::timeout::TimeoutLayer;
use std::time::Duration;

#[layer(TimeoutLayer::new(Duration::from_secs(30)))]
mod api {
    #[get("/users")]
    async fn list_users() -> &'static str {
        "users"  // è‡ªåŠ¨åº”ç”¨ 30 ç§’è¶…æ—¶
    }

    #[get("/posts")]
    async fn list_posts() -> &'static str {
        "posts"  // è‡ªåŠ¨åº”ç”¨ 30 ç§’è¶…æ—¶
    }
}
```

## å‡½æ•°çº§ Layer

ä½¿ç”¨ `#[layer]` å®ä¸ºå•ä¸ªå‡½æ•°æ·»åŠ ä¸­é—´ä»¶:

```rust
use tower_http::timeout::TimeoutLayer;
use tower_http::compression::CompressionLayer;
use std::time::Duration;

// å•ä¸ª layer
#[get("/users")]
#[layer(TimeoutLayer::new(Duration::from_secs(30)))]
async fn list_users() -> &'static str {
    "users"
}

// å¤šä¸ª layerï¼ˆä»ä¸Šåˆ°ä¸‹å£°æ˜,ä»å†…åˆ°å¤–åº”ç”¨ï¼‰
#[post("/data")]
#[layer(TimeoutLayer::new(Duration::from_secs(30)))]
#[layer(CompressionLayer::new())]
async fn process_data() -> &'static str {
    // è°ƒç”¨é“¾: CompressionLayer -> TimeoutLayer -> handler
    "processed"
}
```

## å£°æ˜å¼ä¸­é—´ä»¶

Miko æä¾›äº† `#[middleware]` å®ï¼Œå…è®¸ä½ åƒå†™æ™®é€š Handler ä¸€æ ·å®šä¹‰ä¸­é—´ä»¶ã€‚

### åŸºç¡€ç”¨æ³•

ä½¿ç”¨ `#[middleware]` æ ‡è®°ä¸€ä¸ªå¼‚æ­¥å‡½æ•°ï¼Œå®ƒä¼šè‡ªåŠ¨è·å¾— `_req` (è¯·æ±‚) å’Œ `_next` (ä¸‹ä¸€ä¸ªä¸­é—´ä»¶) å˜é‡ã€‚

```rust
use miko::*;
use miko::macros::*;

#[middleware]
async fn simple_logger() -> AppResult<Resp> {
  println!("Before request");
  let resp = _next.run(_req).await?;
  println!("After request");
  Ok(resp)
}

#[get("/")]
#[layer(simple_logger())] // åº”ç”¨ä¸­é—´ä»¶
async fn hello() -> &'static str {
  "Hello"
}
```

### å‚æ•°æ³¨å…¥

ä¸­é—´ä»¶å‡½æ•°æ”¯æŒä»¥ä¸‹ç±»å‹çš„å‚æ•°ï¼š

1. **æ˜¾å¼å£°æ˜ `Req` å’Œ `Next`**: å¦‚æœä½ æƒ³è‡ªå®šä¹‰å˜é‡åã€‚
2. **æ™®é€šå‚æ•°**: åœ¨åº”ç”¨ä¸­é—´ä»¶æ—¶ä¼ å…¥ã€‚
3. **ä¾èµ–æ³¨å…¥ (`#[dep]`)**: è‡ªåŠ¨ä»ä¾èµ–å®¹å™¨æ³¨å…¥ç»„ä»¶ã€‚
4. **é…ç½®æ³¨å…¥ (`#[config]`)**: è‡ªåŠ¨ä»é…ç½®æ–‡ä»¶æ³¨å…¥å€¼ã€‚

```rust
#[middleware]
async fn auth_guard(
  // æ™®é€šå‚æ•°ï¼Œéœ€è¦åœ¨ #[layer(auth_guard(role))] ä¸­ä¼ å…¥
  required_role: String,
  // ä¾èµ–æ³¨å…¥
  #[dep] db: Arc<Database>,
  // é…ç½®æ³¨å…¥
  #[config("jwt.secret")] secret: String,
  // æ˜¾å¼å£°æ˜ Req å’Œ Next (å¯é€‰)
  req: Req,
  next: Next,
) -> AppResult<Resp> {
  // æ£€æŸ¥æƒé™...
  if !check_permission(&db, &secret, &required_role) {
    return Err(AppError::Forbidden("Access denied".into()));
  }
  next.run(req).await
}

// ä½¿ç”¨ä¸­é—´ä»¶
#[get("/admin")]
#[layer(auth_guard("admin".to_string()))]
async fn admin_panel() -> &'static str {
  "Admin Content"
}
```

### æ•è·ä¸Šä¸‹æ–‡å˜é‡

å£°æ˜å¼ä¸­é—´ä»¶ä¼šè‡ªåŠ¨æ•è·å¤–éƒ¨å˜é‡ï¼ˆCloneï¼‰ï¼Œè¿™ä½¿å¾—ä¼ å‚å˜å¾—éå¸¸æ–¹ä¾¿ã€‚

```rust
#[middleware]
async fn with_id(id: i32) -> AppResult<Resp> {
  println!("ID is {}", id);
  _next.run(_req).await
}

#[get("/")]
#[layer(with_id(10086))]
async fn index() -> &'static str {
  "ok"
}
```

## Tower ä¸­é—´ä»¶å…¼å®¹æ€§

Miko å®Œå…¨å…¼å®¹ Tower ç”Ÿæ€çš„ä¸­é—´ä»¶ï¼ŒåŒ…æ‹¬é‚£äº›å¯èƒ½ä¼šä¿®æ”¹ Body ç±»å‹ï¼ˆå¦‚ `CompressionLayer`ï¼‰æˆ–æŠ›å‡ºé”™è¯¯ï¼ˆå¦‚ `TimeoutLayer`ï¼‰çš„ä¸­é—´ä»¶ã€‚

### æ”¯æŒçš„ä¸­é—´ä»¶ç±»å‹

- **Infallible Middleware**: ä¸ä¼šæŠ¥é”™çš„ä¸­é—´ä»¶ï¼ˆå¦‚ `TraceLayer`ï¼‰ã€‚
- **Fallible Middleware**: å¯èƒ½ä¼šæŠ¥é”™çš„ä¸­é—´ä»¶ï¼ˆå¦‚ `TimeoutLayer`, `RateLimitLayer`ï¼‰ã€‚
  - Miko ä¼šè‡ªåŠ¨æ•è·è¿™äº›é”™è¯¯ï¼Œå°†å…¶è½¬æ¢ä¸º `AppError`ï¼Œæœ€ç»ˆç”Ÿæˆç»Ÿä¸€çš„ JSON é”™è¯¯å“åº”ï¼ˆæˆ–ç¬¦åˆ HTTP è¯­ä¹‰çš„å“åº”ï¼‰ã€‚
- **Body Modifying Middleware**: ä¿®æ”¹å“åº”ä½“çš„ä¸­é—´ä»¶ï¼ˆå¦‚ `CompressionLayer`ï¼‰ã€‚
  - Miko ä¼šè‡ªåŠ¨é€‚é…ä¸åŒçš„ Body ç±»å‹ã€‚

### ç¤ºä¾‹ï¼šè¶…æ—¶ä¸å‹ç¼©

```rust
use tower_http::{timeout::TimeoutLayer, compression::CompressionLayer};
use std::time::Duration;

#[miko]
async fn main() {
    let mut router = Router::new();

    router
        // è‡ªåŠ¨å¤„ç† Gzip å‹ç¼©
        .with_layer(CompressionLayer::new())
        // è‡ªåŠ¨å¤„ç†è¶…æ—¶ï¼ˆæŠ›å‡ºé”™è¯¯ -> 500/504 å“åº”ï¼‰
        .with_layer(TimeoutLayer::new(Duration::from_secs(5)));
}
```

### ServiceBuilder

Tower çš„ `ServiceBuilder` å¯ä»¥æ–¹ä¾¿åœ°ç»„åˆå¤šä¸ªä¸­é—´ä»¶:

```rust
use tower::ServiceBuilder;
use tower_http::{
    trace::TraceLayer,
    compression::CompressionLayer,
    timeout::TimeoutLayer,
};
use std::time::Duration;

#[miko]
async fn main() {
    let middleware = ServiceBuilder::new()
        .layer(TraceLayer::new_for_http())
        .layer(CompressionLayer::new())
        .layer(TimeoutLayer::new(Duration::from_secs(30)));

    let mut router = Router::new();
    router.with_layer(middleware);
}
```

## ä¸‹ä¸€æ­¥

- ğŸ” äº†è§£ [é”™è¯¯å¤„ç†](é”™è¯¯å¤„ç†.md) ç»Ÿä¸€é”™è¯¯æ ¼å¼
- ğŸ“– å­¦ä¹  [å“åº”å¤„ç†](å“åº”å¤„ç†.md) æ„é€ å“åº”
- ğŸš€ æŸ¥çœ‹ [é«˜çº§ç‰¹æ€§](é«˜çº§ç‰¹æ€§.md) æ›´å¤šåŠŸèƒ½
