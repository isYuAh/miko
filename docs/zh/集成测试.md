# 集成测试

Miko 提供了一个强大的 `TestClient` 工具，用于进行进程内（In-Process）的集成测试。它支持从局部路由（`Router`）到全量应用（
`Application`）的无缝测试。

## 核心优势

- **极速执行**：绕过网络协议栈，直接在内存中分发请求。
- **无需端口**：支持高并发测试而无端口冲突。
- **全链路覆盖**：完整触发路由解析、请求提取器、中间件（Layers）以及依赖注入逻辑。
- **一致性**：配合 `build` 模式，确保测试环境与生产环境 100% 一致。

## 完整示例参考

如果你想查看一个涵盖了 DI、多层中间件、路由嵌套等复杂场景的完整集成测试，请参考以下文件：

- **应用代码**: [`miko/examples/basic.rs`](../../miko/examples/basic.rs) (注意其使用的 `#[miko(build)]` 模式)
- **测试代码**: [`miko/tests/basic_integration.rs`](../../miko/tests/basic_integration.rs) (
  展示了如何引用应用代码并进行全量断言)

## 启用方式

在 `Cargo.toml` 中启用 `test` feature：

```toml
[dev-dependencies]
miko = { version = "x.x", features = ["test"] }
```

## 推荐用法：使用 `build` 模式进行全量测试

这是 Miko 推荐的集成测试方式。通过在 `#[miko]` 宏中添加 `build` 参数，你可以将应用启动逻辑封装成一个可导出的工厂函数，从而在测试中完美复用。

### 1. 改造应用入口

在你的 `src/main.rs` 或示例代码中：

```rust,ignore
use miko::*;

#[miko(build, catch)] // 增加 build 参数，并启用 sse/catch 等配置
pub async fn create_app() {
    let mut router = Router::new();

    router.get("/", || async { "Hello Miko" });
    // ... 其他路由、中间件和 DI 组件注册
}

#[tokio::main]
async fn main() {
    // 生产环境下手动获取并运行
    let app = create_app().await;
    app.run().await.unwrap();
}
```

### 2. 编写测试用例

在 `tests/` 目录下，你可以直接引用并测试整个应用：

```rust,ignore
#[path = "../src/main.rs"] // 引用主程序
mod app_mod;

#[tokio::test]
async fn test_full_application() {
    // 1. 获取全量配置的应用实例
    let mut app = app_mod::create_app().await;

    // 2. 创建测试客户端
    let client = app.test_client();

    // 3. 发送请求并断言
    client.get("/").send().await.assert_text("Hello Miko");
}
```

## 基础用法

### 从 Router 测试

如果你只想测试一部分路由，可以直接在 `Router` 上调用 `test_client()`：

```rust,ignore
let mut router = Router::new();
router.get("/ping", || async { "pong" });

let client = router.test_client();
client.get("/ping").send().await.assert_text("pong");
```

## 构造请求与断言

`TestClient` 提供了类似 `reqwest` 的链式 API：

```rust,ignore
let res = client.post("/api/user")
    .header("Authorization", "Bearer token")
    .json(&json!({ "name": "miko" }))
    .send()
    .await;

res.assert_ok();
res.assert_json(json!({ "id": 1 }));
```

### 常用断言方法

- `assert_ok()`: 状态码为 2xx。
- `assert_status(code)`: 断言特定状态码。
- `assert_header(key, value)`: 断言响应头。
- `assert_text(expected)`: 断言响应体文本。
- `assert_json(expected)`: 断言响应体 JSON。

## 测试依赖注入 (DI)

当使用 `Application::test_client()` 或手动初始化时，确保 DI 容器已准备就绪：

```rust
#[tokio::test]
async fn test_di() {
    // 如果不使用 create_app().await，需要手动初始化 DI
    miko::auto::init_container().await;

    let mut router = Router::new();
    router.merge(miko::auto::collect_global_router());

    let client = router.test_client();
    // ... 执行测试
}
```

## 注意事项

1. **尾部斜杠**：Miko 的路由匹配是精确的。如果 `nest("/api", ...)` 内部有根路由 `"/"`，测试时请访问 `/api/`。
2. **Body 聚合**：`TestResponse` 会在创建时自动聚合 Body 流，因此你可以多次调用 `.text()` 或 `.json()` 进行断言而不会丢失数据。
