# 依赖注入

> **需要 `auto` feature**

Miko 提供了内置的依赖注入容器，通过 `#[component]` 和 `#[dep]` 宏实现组件的自动装配和注入。

## 基础概念

依赖注入（Dependency Injection, DI）让你可以：
- 将组件的创建与使用分离
- 在 Handler 中自动获取共享实例
- 简化测试和模块化设计

## 定义组件

使用 `#[component]` 宏标记一个类型为组件：

```rust
use miko::*;
use miko::macros::*;
use std::sync::Arc;

#[component]
impl Database {
    async fn new() -> Self {
        // 初始化数据库连接
        println!("Initializing database connection...");
        Self {
            pool: create_connection_pool().await,
        }
    }

    pub fn query_users(&self) -> Vec<User> {
        // 查询逻辑
        vec[]
    }
}
```

### 组件要求

- 必须实现 `async fn new() -> Self`
- `new` 方法用于创建组件实例
- 组件会被包装为 `Arc<T>` 共享

## 注入组件

在 Handler 中使用 `#[dep]` 注入组件：

```rust
#[get("/users")]
async fn list_users(#[dep] db: Arc<Database>) -> Json<Vec<User>> {
    let users = db.query_users();
    Json(users)
}

#[get("/users/{id}")]
async fn get_user(
    #[path] id: u32,
    #[dep] db: Arc<Database>,
) -> AppResult<Json<User>> {
    let user = db.find_user(id)
        .ok_or(AppError::NotFound("User not found".into()))?;
    Ok(Json(user))
}
```

### 多个依赖

一个 Handler 可以注入多个组件：

```rust
#[component]
impl Cache {
    async fn new() -> Self {
        Self { redis: connect_redis().await }
    }

    pub fn get(&self, key: &str) -> Option<String> {
        // ...
    }
}

#[get("/users/{id}")]
async fn get_user(
    #[path] id: u32,
    #[dep] db: Arc<Database>,
    #[dep] cache: Arc<Cache>,
) -> AppResult<Json<User>> {
    // 先查缓存
    if let Some(cached) = cache.get(&format!("user:{}", id)) {
        return Ok(Json(serde_json::from_str(&cached)?));
    }

    // 查数据库
    let user = db.find_user(id)?;
    Ok(Json(user))
}
```

## 完整示例

```rust
use miko::*;
use miko::macros::*;
use std::sync::Arc;

// 数据库组件
#[component]
impl Database {
    async fn new() -> Self {
        println!("📦 Initializing database...");
        Self {
            // 实际项目中这里会创建连接池
        }
    }

    pub fn get_user(&self, id: u32) -> Option<User> {
        // 查询逻辑
        Some(User {
            id,
            name: "Alice".into(),
            email: "alice@example.com".into(),
        })
    }
}

// 缓存组件
#[component]
impl Cache {
    async fn new() -> Self {
        println!("📦 Initializing cache...");
        Self {
            // Redis 连接等
        }
    }

    pub fn set(&self, key: &str, value: &str) {
        println!("Cache SET: {} = {}", key, value);
    }

    pub fn get(&self, key: &str) -> Option<String> {
        None  // 示例
    }
}

// 日志服务组件
#[component]
impl Logger {
    async fn new() -> Self {
        println!("📦 Initializing logger...");
        Self {}
    }

    pub fn log(&self, message: &str) {
        println!("[LOG] {}", message);
    }
}

#[derive(Serialize)]
struct User {
    id: u32,
    name: String,
    email: String,
}

// 使用依赖注入
#[get("/users/{id}")]
async fn get_user(
    #[path] id: u32,
    #[dep] db: Arc<Database>,
    #[dep] cache: Arc<Cache>,
    #[dep] logger: Arc<Logger>,
) -> AppResult<Json<User>> {
    logger.log(&format!("Fetching user {}", id));

    // 尝试从缓存获取
    let cache_key = format!("user:{}", id);
    if let Some(cached) = cache.get(&cache_key) {
        logger.log("Cache hit!");
        return Ok(Json(serde_json::from_str(&cached)?));
    }

    // 从数据库查询
    let user = db.get_user(id)
        .ok_or(AppError::NotFound("User not found".into()))?;

    // 写入缓存
    cache.set(&cache_key, &serde_json::to_string(&user)?);

    Ok(Json(user))
}

#[miko]
async fn main() {
    // 组件会自动注册和初始化
    println!("🚀 Server running");
}
```

## 依赖容器

### 自动初始化

使用 `#[miko]` 宏时，依赖容器会自动初始化：

```rust
#[miko]
async fn main() {
    // 1. 依赖容器初始化
    // 2. 路由收集
    // 3. 应用启动
}
```

### 预热（Prewarm）

默认情况下，组件是惰性创建的（第一次使用时）。你可以启用预热：

```rust
#[component(prewarm = true)]
impl Database {
    async fn new() -> Self {
        // 应用启动时立即初始化
        Self { /* ... */ }
    }
}
```

预热组件会在应用启动后异步初始化，不会阻塞服务器启动。

## 组件生命周期

### 单例模式

所有组件都是单例的，在整个应用生命周期中只创建一次：

```rust
#[component]
impl Database {
    async fn new() -> Self {
        println!("This will only print once!");
        Self {}
    }
}
```

### 共享引用

组件通过 `Arc<T>` 共享，可以在多个 Handler 和线程间安全使用：

```rust
#[get("/route1")]
async fn handler1(#[dep] db: Arc<Database>) {
    // 使用同一个 Database 实例
}

#[get("/route2")]
async fn handler2(#[dep] db: Arc<Database>) {
    // 使用同一个 Database 实例
}
```

## 组件间依赖

### 构造函数注入

组件的 `new` 函数可以接收其他组件作为依赖（必须是 `Arc<T>` 类型）：

```rust
// 基础组件
#[component]
impl Database {
    async fn new() -> Self {
        Self { pool: create_pool().await }
    }
}

#[component]
impl Cache {
    async fn new() -> Self {
        Self { redis: connect_redis().await }
    }
}

// 依赖其他组件的组件
#[component]
impl UserService {
    async fn new(
        db: Arc<Database>,      // 注入 Database
        cache: Arc<Cache>,      // 注入 Cache
    ) -> Self {
        println!("UserService initialized with db and cache");
        Self { db, cache }
    }

    pub fn get_user(&self, id: u32) -> Option<User> {
        // 可以直接使用注入的依赖
        if let Some(cached) = self.cache.get(&format!("user:{}", id)) {
            return Some(cached);
        }
        self.db.find_user(id)
    }
}
```

使用组合后的服务：

```rust
#[get("/users/{id}")]
async fn get_user(
    #[path] id: u32,
    #[dep] user_service: Arc<UserService>,  // 直接注入组合服务
) -> AppResult<Json<User>> {
    let user = user_service.get_user(id)
        .ok_or(AppError::NotFound("User not found".into()))?;
    Ok(Json(user))
}
```

### 依赖解析顺序

框架会自动分析依赖关系并按正确顺序初始化组件：

```rust
// 初始化顺序：Database -> Cache -> UserService
#[component]
impl Database {
    async fn new() -> Self { /* ... */ }
}

#[component]
impl Cache {
    async fn new() -> Self { /* ... */ }
}

#[component]
impl UserService {
    async fn new(db: Arc<Database>, cache: Arc<Cache>) -> Self { /* ... */ }
}
```

> **注意**: 不要创建循环依赖（A 依赖 B，B 又依赖 A），这会导致初始化失败。

## 与 State 的区别

| 特性 | 依赖注入 `#[dep]` | 全局状态 `State<T>` |
|------|------------------|-------------------|
| 定义方式 | `#[component]` 宏 | `Router::with_state()` |
| 自动注册 | 是 | 否 |
| 类型数量 | 多个不同类型 | 单个类型 |
| 使用场景 | 多个独立服务 | 共享应用状态 |
| Feature | 需要 `auto` | 无需 feature |

### 何时使用依赖注入

- ✅ 多个独立的服务（数据库、缓存、日志等）
- ✅ 需要自动初始化
- ✅ 希望代码更模块化
- **当你使用了#[miko]的时候，由于自动注册路由，你很可能不能手动设置state**

### 何时使用 State

- ✅ 简单的共享状态
- ✅ 不需要 `auto` feature
- ✅ 只有一个状态对象
- **或者是你没开auto导致没法用依赖注入**

## 实际应用示例

### Web 应用架构

```rust
use miko::*;
use miko::macros::*;
use std::sync::Arc;

// 数据访问层
#[component]
impl UserRepository {
    async fn new() -> Self {
        Self {
            pool: create_db_pool().await,
        }
    }

    pub async fn find_by_id(&self, id: u32) -> Option<User> {
        // 数据库查询
    }

    pub async fn create(&self, data: CreateUser) -> Result<User, Error> {
        // 插入数据
    }
}

// 认证服务
#[component]
impl AuthService {
    async fn new() -> Self {
        Self {
            jwt_secret: std::env::var("JWT_SECRET").unwrap(),
        }
    }

    pub fn verify_token(&self, token: &str) -> Option<UserId> {
        // 验证 JWT
    }

    pub fn generate_token(&self, user_id: u32) -> String {
        // 生成 JWT
    }
}

// 邮件服务
#[component]
impl EmailService {
    async fn new() -> Self {
        Self {
            smtp_config: load_smtp_config(),
        }
    }

    pub async fn send(&self, to: &str, subject: &str, body: &str) {
        // 发送邮件
    }
}

// Handler 使用多个服务
#[post("/register")]
async fn register(
    Json(data): Json<RegisterData>,
    #[dep] users: Arc<UserRepository>,
    #[dep] auth: Arc<AuthService>,
    #[dep] email: Arc<EmailService>,
) -> AppResult<Json<AuthResponse>> {
    // 创建用户
    let user = users.create(data.into()).await?;

    // 生成 token
    let token = auth.generate_token(user.id);

    // 发送欢迎邮件
    email.send(
        &user.email,
        "Welcome!",
        "Thanks for registering"
    ).await;

    Ok(Json(AuthResponse { token, user }))
}

#[miko]
async fn main() {
    println!("🚀 Server starting...");
}
```

## 下一步

- 🔧 了解 [配置管理](配置管理.md) 注入配置
- 🔐 使用 [中间件](中间件与层.md) 添加全局功能
- 📖 查看 [基础概念](基础概念.md) 理解架构
