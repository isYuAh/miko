# ä¾èµ–æ³¨å…¥

> **éœ€è¦ `auto` feature**

Miko æä¾›äº†å†…ç½®çš„ä¾èµ–æ³¨å…¥å®¹å™¨ï¼Œé€šè¿‡ `#[component]` å’Œ `#[dep]` å®å®ç°ç»„ä»¶çš„è‡ªåŠ¨è£…é…å’Œæ³¨å…¥ã€‚

## åŸºç¡€æ¦‚å¿µ

ä¾èµ–æ³¨å…¥ï¼ˆDependency Injection, DIï¼‰è®©ä½ å¯ä»¥ï¼š
- å°†ç»„ä»¶çš„åˆ›å»ºä¸ä½¿ç”¨åˆ†ç¦»
- åœ¨ Handler ä¸­è‡ªåŠ¨è·å–å…±äº«å®ä¾‹
- ç®€åŒ–æµ‹è¯•å’Œæ¨¡å—åŒ–è®¾è®¡

## å®šä¹‰ç»„ä»¶

ä½¿ç”¨ `#[component]` å®æ ‡è®°ä¸€ä¸ªç±»å‹ä¸ºç»„ä»¶ï¼š

```rust
use miko::*;
use miko::macros::*;
use std::sync::Arc;

#[component]
impl Database {
    async fn new() -> Self {
        // åˆå§‹åŒ–æ•°æ®åº“è¿æ¥
        println!("Initializing database connection...");
        Self {
            pool: create_connection_pool().await,
        }
    }

    pub fn query_users(&self) -> Vec<User> {
        // æŸ¥è¯¢é€»è¾‘
        vec[]
    }
}
```

### ç»„ä»¶è¦æ±‚

- å¿…é¡»å®ç° `async fn new() -> Self`
- `new` æ–¹æ³•ç”¨äºåˆ›å»ºç»„ä»¶å®ä¾‹
- ç»„ä»¶ä¼šè¢«åŒ…è£…ä¸º `Arc<T>` å…±äº«

## æ³¨å…¥ç»„ä»¶

åœ¨ Handler ä¸­ä½¿ç”¨ `#[dep]` æ³¨å…¥ç»„ä»¶ï¼š

```rust
#[get("/users")]
async fn list_users(#[dep] db: Arc<Database>) -> Json<Vec<User>> {
    let users = db.query_users();
    Json(users)
}

#[get("/users/{id}")]
async fn get_user(
    #[path] id: u32,
    #[dep] db: Arc<Database>,
) -> AppResult<Json<User>> {
    let user = db.find_user(id)
        .ok_or(AppError::NotFound("User not found".into()))?;
    Ok(Json(user))
}
```

### å¤šä¸ªä¾èµ–

ä¸€ä¸ª Handler å¯ä»¥æ³¨å…¥å¤šä¸ªç»„ä»¶ï¼š

```rust
#[component]
impl Cache {
    async fn new() -> Self {
        Self { redis: connect_redis().await }
    }

    pub fn get(&self, key: &str) -> Option<String> {
        // ...
    }
}

#[get("/users/{id}")]
async fn get_user(
    #[path] id: u32,
    #[dep] db: Arc<Database>,
    #[dep] cache: Arc<Cache>,
) -> AppResult<Json<User>> {
    // å…ˆæŸ¥ç¼“å­˜
    if let Some(cached) = cache.get(&format!("user:{}", id)) {
        return Ok(Json(serde_json::from_str(&cached)?));
    }

    // æŸ¥æ•°æ®åº“
    let user = db.find_user(id)?;
    Ok(Json(user))
}
```

## å®Œæ•´ç¤ºä¾‹

```rust
use miko::*;
use miko::macros::*;
use std::sync::Arc;

// æ•°æ®åº“ç»„ä»¶
#[component]
impl Database {
    async fn new() -> Self {
        println!("ğŸ“¦ Initializing database...");
        Self {
            // å®é™…é¡¹ç›®ä¸­è¿™é‡Œä¼šåˆ›å»ºè¿æ¥æ± 
        }
    }

    pub fn get_user(&self, id: u32) -> Option<User> {
        // æŸ¥è¯¢é€»è¾‘
        Some(User {
            id,
            name: "Alice".into(),
            email: "alice@example.com".into(),
        })
    }
}

// ç¼“å­˜ç»„ä»¶
#[component]
impl Cache {
    async fn new() -> Self {
        println!("ğŸ“¦ Initializing cache...");
        Self {
            // Redis è¿æ¥ç­‰
        }
    }

    pub fn set(&self, key: &str, value: &str) {
        println!("Cache SET: {} = {}", key, value);
    }

    pub fn get(&self, key: &str) -> Option<String> {
        None  // ç¤ºä¾‹
    }
}

// æ—¥å¿—æœåŠ¡ç»„ä»¶
#[component]
impl Logger {
    async fn new() -> Self {
        println!("ğŸ“¦ Initializing logger...");
        Self {}
    }

    pub fn log(&self, message: &str) {
        println!("[LOG] {}", message);
    }
}

#[derive(Serialize)]
struct User {
    id: u32,
    name: String,
    email: String,
}

// ä½¿ç”¨ä¾èµ–æ³¨å…¥
#[get("/users/{id}")]
async fn get_user(
    #[path] id: u32,
    #[dep] db: Arc<Database>,
    #[dep] cache: Arc<Cache>,
    #[dep] logger: Arc<Logger>,
) -> AppResult<Json<User>> {
    logger.log(&format!("Fetching user {}", id));

    // å°è¯•ä»ç¼“å­˜è·å–
    let cache_key = format!("user:{}", id);
    if let Some(cached) = cache.get(&cache_key) {
        logger.log("Cache hit!");
        return Ok(Json(serde_json::from_str(&cached)?));
    }

    // ä»æ•°æ®åº“æŸ¥è¯¢
    let user = db.get_user(id)
        .ok_or(AppError::NotFound("User not found".into()))?;

    // å†™å…¥ç¼“å­˜
    cache.set(&cache_key, &serde_json::to_string(&user)?);

    Ok(Json(user))
}

#[miko]
async fn main() {
    // ç»„ä»¶ä¼šè‡ªåŠ¨æ³¨å†Œå’Œåˆå§‹åŒ–
    println!("ğŸš€ Server running");
}
```

## ä¾èµ–å®¹å™¨

### è‡ªåŠ¨åˆå§‹åŒ–

ä½¿ç”¨ `#[miko]` å®æ—¶ï¼Œä¾èµ–å®¹å™¨ä¼šè‡ªåŠ¨åˆå§‹åŒ–ï¼š

```rust
#[miko]
async fn main() {
    // 1. ä¾èµ–å®¹å™¨åˆå§‹åŒ–
    // 2. è·¯ç”±æ”¶é›†
    // 3. åº”ç”¨å¯åŠ¨
}
```

### é¢„çƒ­ï¼ˆPrewarmï¼‰

é»˜è®¤æƒ…å†µä¸‹ï¼Œç»„ä»¶æ˜¯æƒ°æ€§åˆ›å»ºçš„ï¼ˆç¬¬ä¸€æ¬¡ä½¿ç”¨æ—¶ï¼‰ã€‚ä½ å¯ä»¥å¯ç”¨é¢„çƒ­ï¼š

```rust
#[component(prewarm = true)]
impl Database {
    async fn new() -> Self {
        // åº”ç”¨å¯åŠ¨æ—¶ç«‹å³åˆå§‹åŒ–
        Self { /* ... */ }
    }
}
```

é¢„çƒ­ç»„ä»¶ä¼šåœ¨åº”ç”¨å¯åŠ¨åå¼‚æ­¥åˆå§‹åŒ–ï¼Œä¸ä¼šé˜»å¡æœåŠ¡å™¨å¯åŠ¨ã€‚

## ç»„ä»¶ç”Ÿå‘½å‘¨æœŸ

### å•ä¾‹æ¨¡å¼

æ‰€æœ‰ç»„ä»¶éƒ½æ˜¯å•ä¾‹çš„ï¼Œåœ¨æ•´ä¸ªåº”ç”¨ç”Ÿå‘½å‘¨æœŸä¸­åªåˆ›å»ºä¸€æ¬¡ï¼š

```rust
#[component]
impl Database {
    async fn new() -> Self {
        println!("This will only print once!");
        Self {}
    }
}
```

### å…±äº«å¼•ç”¨

ç»„ä»¶é€šè¿‡ `Arc<T>` å…±äº«ï¼Œå¯ä»¥åœ¨å¤šä¸ª Handler å’Œçº¿ç¨‹é—´å®‰å…¨ä½¿ç”¨ï¼š

```rust
#[get("/route1")]
async fn handler1(#[dep] db: Arc<Database>) {
    // ä½¿ç”¨åŒä¸€ä¸ª Database å®ä¾‹
}

#[get("/route2")]
async fn handler2(#[dep] db: Arc<Database>) {
    // ä½¿ç”¨åŒä¸€ä¸ª Database å®ä¾‹
}
```

## ç»„ä»¶é—´ä¾èµ–

### æ„é€ å‡½æ•°æ³¨å…¥

ç»„ä»¶çš„ `new` å‡½æ•°å¯ä»¥æ¥æ”¶å…¶ä»–ç»„ä»¶ä½œä¸ºä¾èµ–ï¼ˆå¿…é¡»æ˜¯ `Arc<T>` ç±»å‹ï¼‰ï¼š

```rust
// åŸºç¡€ç»„ä»¶
#[component]
impl Database {
    async fn new() -> Self {
        Self { pool: create_pool().await }
    }
}

#[component]
impl Cache {
    async fn new() -> Self {
        Self { redis: connect_redis().await }
    }
}

// ä¾èµ–å…¶ä»–ç»„ä»¶çš„ç»„ä»¶
#[component]
impl UserService {
    async fn new(
        db: Arc<Database>,      // æ³¨å…¥ Database
        cache: Arc<Cache>,      // æ³¨å…¥ Cache
    ) -> Self {
        println!("UserService initialized with db and cache");
        Self { db, cache }
    }

    pub fn get_user(&self, id: u32) -> Option<User> {
        // å¯ä»¥ç›´æ¥ä½¿ç”¨æ³¨å…¥çš„ä¾èµ–
        if let Some(cached) = self.cache.get(&format!("user:{}", id)) {
            return Some(cached);
        }
        self.db.find_user(id)
    }
}
```

ä½¿ç”¨ç»„åˆåçš„æœåŠ¡ï¼š

```rust
#[get("/users/{id}")]
async fn get_user(
    #[path] id: u32,
    #[dep] user_service: Arc<UserService>,  // ç›´æ¥æ³¨å…¥ç»„åˆæœåŠ¡
) -> AppResult<Json<User>> {
    let user = user_service.get_user(id)
        .ok_or(AppError::NotFound("User not found".into()))?;
    Ok(Json(user))
}
```

### ä¾èµ–è§£æé¡ºåº

æ¡†æ¶ä¼šè‡ªåŠ¨åˆ†æä¾èµ–å…³ç³»å¹¶æŒ‰æ­£ç¡®é¡ºåºåˆå§‹åŒ–ç»„ä»¶ï¼š

```rust
// åˆå§‹åŒ–é¡ºåºï¼šDatabase -> Cache -> UserService
#[component]
impl Database {
    async fn new() -> Self { /* ... */ }
}

#[component]
impl Cache {
    async fn new() -> Self { /* ... */ }
}

#[component]
impl UserService {
    async fn new(db: Arc<Database>, cache: Arc<Cache>) -> Self { /* ... */ }
}
```

> **æ³¨æ„**: ä¸è¦åˆ›å»ºå¾ªç¯ä¾èµ–ï¼ˆA ä¾èµ– Bï¼ŒB åˆä¾èµ– Aï¼‰ï¼Œè¿™ä¼šå¯¼è‡´åˆå§‹åŒ–å¤±è´¥ã€‚

## ä¸ State çš„åŒºåˆ«

| ç‰¹æ€§ | ä¾èµ–æ³¨å…¥ `#[dep]` | å…¨å±€çŠ¶æ€ `State<T>` |
|------|------------------|-------------------|
| å®šä¹‰æ–¹å¼ | `#[component]` å® | `Router::with_state()` |
| è‡ªåŠ¨æ³¨å†Œ | æ˜¯ | å¦ |
| ç±»å‹æ•°é‡ | å¤šä¸ªä¸åŒç±»å‹ | å•ä¸ªç±»å‹ |
| ä½¿ç”¨åœºæ™¯ | å¤šä¸ªç‹¬ç«‹æœåŠ¡ | å…±äº«åº”ç”¨çŠ¶æ€ |
| Feature | éœ€è¦ `auto` | æ— éœ€ feature |

### ä½•æ—¶ä½¿ç”¨ä¾èµ–æ³¨å…¥

- âœ… å¤šä¸ªç‹¬ç«‹çš„æœåŠ¡ï¼ˆæ•°æ®åº“ã€ç¼“å­˜ã€æ—¥å¿—ç­‰ï¼‰
- âœ… éœ€è¦è‡ªåŠ¨åˆå§‹åŒ–
- âœ… å¸Œæœ›ä»£ç æ›´æ¨¡å—åŒ–
- **å½“ä½ ä½¿ç”¨äº†#[miko]çš„æ—¶å€™ï¼Œç”±äºè‡ªåŠ¨æ³¨å†Œè·¯ç”±ï¼Œä½ å¾ˆå¯èƒ½ä¸èƒ½æ‰‹åŠ¨è®¾ç½®state**

### ä½•æ—¶ä½¿ç”¨ State

- âœ… ç®€å•çš„å…±äº«çŠ¶æ€
- âœ… ä¸éœ€è¦ `auto` feature
- âœ… åªæœ‰ä¸€ä¸ªçŠ¶æ€å¯¹è±¡
- **æˆ–è€…æ˜¯ä½ æ²¡å¼€autoå¯¼è‡´æ²¡æ³•ç”¨ä¾èµ–æ³¨å…¥**

## å®é™…åº”ç”¨ç¤ºä¾‹

### Web åº”ç”¨æ¶æ„

```rust
use miko::*;
use miko::macros::*;
use std::sync::Arc;

// æ•°æ®è®¿é—®å±‚
#[component]
impl UserRepository {
    async fn new() -> Self {
        Self {
            pool: create_db_pool().await,
        }
    }

    pub async fn find_by_id(&self, id: u32) -> Option<User> {
        // æ•°æ®åº“æŸ¥è¯¢
    }

    pub async fn create(&self, data: CreateUser) -> Result<User, Error> {
        // æ’å…¥æ•°æ®
    }
}

// è®¤è¯æœåŠ¡
#[component]
impl AuthService {
    async fn new() -> Self {
        Self {
            jwt_secret: std::env::var("JWT_SECRET").unwrap(),
        }
    }

    pub fn verify_token(&self, token: &str) -> Option<UserId> {
        // éªŒè¯ JWT
    }

    pub fn generate_token(&self, user_id: u32) -> String {
        // ç”Ÿæˆ JWT
    }
}

// é‚®ä»¶æœåŠ¡
#[component]
impl EmailService {
    async fn new() -> Self {
        Self {
            smtp_config: load_smtp_config(),
        }
    }

    pub async fn send(&self, to: &str, subject: &str, body: &str) {
        // å‘é€é‚®ä»¶
    }
}

// Handler ä½¿ç”¨å¤šä¸ªæœåŠ¡
#[post("/register")]
async fn register(
    Json(data): Json<RegisterData>,
    #[dep] users: Arc<UserRepository>,
    #[dep] auth: Arc<AuthService>,
    #[dep] email: Arc<EmailService>,
) -> AppResult<Json<AuthResponse>> {
    // åˆ›å»ºç”¨æˆ·
    let user = users.create(data.into()).await?;

    // ç”Ÿæˆ token
    let token = auth.generate_token(user.id);

    // å‘é€æ¬¢è¿é‚®ä»¶
    email.send(
        &user.email,
        "Welcome!",
        "Thanks for registering"
    ).await;

    Ok(Json(AuthResponse { token, user }))
}

#[miko]
async fn main() {
    println!("ğŸš€ Server starting...");
}
```

## ä¸‹ä¸€æ­¥

- ğŸ”§ äº†è§£ [é…ç½®ç®¡ç†](é…ç½®ç®¡ç†.md) æ³¨å…¥é…ç½®
- ğŸ” ä½¿ç”¨ [ä¸­é—´ä»¶](ä¸­é—´ä»¶ä¸å±‚.md) æ·»åŠ å…¨å±€åŠŸèƒ½
- ğŸ“– æŸ¥çœ‹ [åŸºç¡€æ¦‚å¿µ](åŸºç¡€æ¦‚å¿µ.md) ç†è§£æ¶æ„
