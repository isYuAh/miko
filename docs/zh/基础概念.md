# 基础概念

本章节介绍 Miko 框架的核心概念和架构设计。

## 核心组件

Miko 框架由以下核心组件构成：

```
Application (应用程序)
    ├── Router (路由器)
    │   ├── Handler (处理器)
    │   └── Middleware (中间件)
    ├── Config (配置)
    └── DependencyContainer (依赖容器)
```

### Application (应用程序)

`Application` 是框架的入口点，负责：
- 管理应用配置
- 持有路由服务
- 启动 HTTP 服务器

```rust
use miko::*;
use miko::macros::*;

let router = Router::new()
    .get("/", handler);

// 使用文件配置
// 你可以
let app = Application::new_(router);
// 或使用
let config = ApplicationConfig::load_().unwrap();
let app = Application::new(config, router);

// 运行应用
app.run().await.unwrap();
```

### Router (路由器)

`Router` 负责路由管理和请求分发：
- 注册路由及其处理器
- 管理全局状态
- 应用中间件层

```rust
let router = Router::new()
    .get("/users", list_users)
    .post("/users", create_user)
    .get("/users/{id}", get_user);
```

路由器支持泛型状态参数：

```rust
struct AppState {
    db: Database,
    cache: Cache,
}

let state = Arc::new(AppState { /* ... */ });
let router = Router::new()
    .with_state(state)
    .get("/", handler);
```

### Handler (处理器)

Handler 是处理请求的函数，可以是任何满足以下条件的异步函数：
- 参数实现 `FromRequest` 或 `FromRequestParts` trait（注意只有最后一个可以是FromRequest）
- 返回类型实现 `IntoResponse` trait

```rust
// 最简单的 handler
async fn simple() -> &'static str {
    "Hello"
}

// 带参数的 handler
async fn with_params(
    Path(id): Path<u32>,
    Json(data): Json<CreateUser>,
) -> Json<User> {
    // ...
}

// 返回 Result 的 handler
async fn fallible() -> AppResult<Json<User>> {
    // ...
}
```

## 请求处理流程

Miko 的请求处理遵循以下流程：

```
HTTP 请求
    ↓
[Hyper Server]
    ↓
[Tower Middleware Stack]  ← 中间件链
    ↓
[Router]  ← 路由匹配
    ↓
[Extract Parameters]  ← 提取请求数据
    ↓
[Handler]  ← 业务逻辑
    ↓
[IntoResponse]  ← 转换为响应
    ↓
[Tower Middleware Stack]  ← 响应中间件
    ↓
HTTP 响应
```

### 1. 路由匹配

Router 根据请求方法和路径查找对应的处理器：

```rust
// 定义路由
router
    .get("/users", list_users)      // GET /users
    .get("/users/{id}", get_user)   // GET /users/123
    .post("/users", create_user);    // POST /users
```

路径参数会被提取并存储在 `PathParams` 中。

### 2. 参数提取

Handler 的参数会自动从请求中提取：

```rust
async fn handler(
    Path(id): Path<u32>,           // 从路径提取
    Query(params): Query<MyQuery>, // 从查询字符串提取
    Json(body): Json<MyData>,      // 从请求体提取
    State(state): State<AppState>, // 从全局状态提取
) -> impl IntoResponse {
    // ...
}
```

提取器按照以下顺序执行：
1. **FromRequestParts** - 不消费请求体（Path、Query、Headers 等）
2. **FromRequest** - 可能消费请求体（Json、Form、Multipart 等）

> ⚠️ **注意**: 只能有一个提取器消费请求体！

### 3. 业务处理

Handler 执行业务逻辑，可以：
- 访问数据库
- 调用外部服务
- 处理业务规则
- 返回结果或错误

### 4. 响应转换

返回值通过 `IntoResponse` trait 转换为 HTTP 响应：

```rust
// 直接返回字符串
async fn text_response() -> &'static str {
    "Hello"
}

// 返回 JSON
async fn json_response() -> Json<User> {
    Json(user)
}

// 返回元组（状态码 + 数据）
async fn with_status() -> (StatusCode, Json<User>) {
    (StatusCode::CREATED, Json(user))
}

// 返回 Result
async fn fallible() -> AppResult<Json<User>> {
    Ok(Json(user))
}
```

## 类型系统

### FromRequest

从完整的请求中提取数据，可以消费请求体：

```rust
pub trait FromRequest<S, M = ()>: Sized {
    fn from_request(req: Req, state: Arc<S>) -> FRFut<Self>;
}
```

实现 `FromRequest` 的类型：
- `Json<T>` - JSON 请求体
- `Form<T>` - 表单数据
- `Multipart` - 文件上传，获取原始流
- `MultipartResult` - 文件上传，获取解析完成后的结构体，为了放置内存过大，使用临时文件存储，通过MultipartFileDiskLinker访问
- `ValidatedJson<T>` - 验证的 JSON（使用garde）

### FromRequestParts

从请求的部分信息中提取数据，不消费请求体：

```rust
pub trait FromRequestParts<S, M = ()>: Sized {
    fn from_request_parts(parts: &mut Parts, state: Arc<S>) -> FRFut<Self>;
}
```

实现 `FromRequestParts` 的类型：
- `Path<T>` - 路径参数
- `Query<T>` - 查询参数
- `State<T>` - 全局状态
- `HeaderMap` - 请求头
- `Method` - HTTP 方法
- `Uri` - 请求 URI

### IntoResponse

将类型转换为 HTTP 响应：

```rust
pub trait IntoResponse {
    fn into_response(self) -> Response;
}
```

框架为以下类型提供了实现：
- 基础类型：`&str`, `String`, `&[u8]`, `Vec<u8>`
- JSON：`Json<T>`
- HTML：`Html<T>`
- 元组：`(StatusCode, T)`, `(HeaderMap, T)`
- 结果：`Result<T, E>`

## Features 配置

Miko 采用模块化设计，通过 Cargo features 控制功能：

```toml
[dependencies]
miko = { version = "0.3.5", features = ["full"] }
```

### 可用 Features

| Feature | 描述 | 包含内容 |
|---------|------|----------|
| `full` | 所有功能 | 包含下面所有 features |
| `macro` | 路由宏 | `#[get]`, `#[post]` 等路由宏 |
| `auto` | 自动功能 | 自动路由注册、依赖注入 |
| `ext` | 扩展功能 | CORS、静态文件服务 |
| `utoipa` | OpenAPI | API 文档生成 |
| `validation` | 数据验证 | garde 集成 |

### 按需启用

```toml
# 只启用需要的功能
miko = { version = "0.3.5", features = ["macro", "auto"] }
```

### 最小配置

不使用任何 feature：

```toml
miko = "0.3.5"
```

此时只能使用核心功能，需手动注册路由：

```rust
let router = Router::new()
    .route("/", Method::GET, handler);
```

## 异步运行时

Miko 基于 Tokio 运行时构建，需要在异步上下文中运行：

```rust
#[tokio::main]
async fn main() {
    let router = Router::new()
        .get("/", handler);

    Application::new_(router)
        .run()
        .await
        .unwrap();
}
```

所有的 handler 都是异步函数：

```rust
async fn handler() -> &'static str {
    // 可以执行异步操作
    tokio::time::sleep(Duration::from_secs(1)).await;
    "Hello"
}
```

## Tower 生态集成

Miko 完全兼容 [Tower](https://github.com/tower-rs/tower) 生态系统：

```rust
use tower::ServiceBuilder;
use tower_http::compression::CompressionLayer;

router.service(
        "/no_macro",
        handler
            .with_state(Arc::new(router.state.clone())) //需要先确定state，转换为Service
            .layer(layer), //Service可以链式调用应用layer
    ); // 使用 Tower 中间件
```

这使得你可以使用 Tower 生态系统中的大量中间件，如：
- `tower-http` - HTTP 相关中间件
- `tower-governor` - 限流
- `tower-timeout` - 超时控制

详见 [中间件与层](中间件与层.md)。

## 错误处理

Miko 提供统一的错误处理机制：

```rust
use miko::{AppError, AppResult};

async fn handler() -> AppResult<Json<User>> {
    let user = get_user()
        .await
        .map_err(|e| AppError::NotFound(format!("User not found: {}", e)))?;

    Ok(Json(user))
}
```

框架会自动将错误转换为标准的 JSON 响应格式：

```json
{
    "status": 404,
    "error": "NOT_FOUND",
    "message": "404 Not Found",
    "trace_id": "trace-641d28a04dfe2-ThreadId3",
    "timestamp": 1761222374
}
```

详见 [错误处理](错误处理.md)。

## 依赖注入

使用 `#[component]` 和 `#[dep]` 实现依赖注入：

```rust
#[component]
impl Database {
    async fn new() -> Self {
        Self::connect().await
    }
}

#[get("/users")]
async fn list_users(#[dep] db: Arc<Database>) -> Json<Vec<User>> {
    // 使用注入的数据库实例
}
```

> **需要 `auto` feature**

详见 [依赖注入](依赖注入.md)。

## 下一步

- 📖 学习 [路由系统](路由系统.md) 的详细用法
- 🔍 了解 [请求提取器](请求提取器.md) 的种类和用法
- 📤 掌握 [响应处理](响应处理.md) 的各种方式
- ⚠️ 深入 [错误处理](错误处理.md) 机制
